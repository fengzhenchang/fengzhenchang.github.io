<!-- 源 -->
<div class="u-col">
    <div class="u-block">
        <h3>buffer<span>-</span></h3>
        <div class="u-list">
            <h4>[<span>+</span>] 字符集</h4>
            <ul style="display:none">
                <li>
                    <a href="">ASCII</a>
                    <span>
                        <b>ascii</b> <br>
                        作用：表语英语及西欧语言。 <br>
                        位数：ASCII是用7位表示的，能表示128个字符；其扩展使用8位表示，表示256个字符。 <br>
                        范围：ASCII从00到7F，扩展从00到FF <hr>
                        <b>iso8859-1</b> <br>
                        作用：扩展ASCII，表示西欧、希腊语等。  <br>
                        位数：8位 <br>
                        范围：从00到FF，兼容ASCII字符集
                    </span>
                </li>
                <li>
                    <a href="">GB</a>
                    <span>
                        <b>GB2312字符集</b> <br>
                        作用：国家简体中文字符集，兼容ASCII。 <br>
                        位数：使用2个字节表示，能表示7445个符号，包括6763个汉字，几乎覆盖所有高频率汉字。 <br>
                        范围：高字节从A1到F7, 低字节从A1到FE。将高字节和低字节分别加上0XA0即可得到编码。  <hr>
                        <b>GBK字符集</b> <br>
                        作用：它是GB2312的扩展，加入对繁体字的支持，兼容GB2312。 <br>
                        位数：使用2个字节表示，可表示21886个字符。 <br>
                        范围：高字节从81到FE，低字节从40到FE。 <hr>
                        <b>BIG5字符集</b> <br>
                        作用：它解决了中文、日文、朝鲜语等的编码，兼容GBK。 <br>
                        位数：它采用变字节表示(1 ASCII，2，4字节)。可表示27484个文字。 <br>
                        范围：1字节从00到7F; 2字节高字节从81到FE，低字节从40到7E和80到FE；4字节第一三字节从81到FE，第二四字节从30到39。 <hr>
                    </span>
                </li>
                <li>
                    <a href="">Unicode</a>
                    <span>
                        <b>UTF-8/UTF-32/UTF-16/UTF-7</b> <br>
                        作用：为世界650种语言进行统一编码，兼容ISO-8859-1。 <br>
                        位数：UNICODE字符集有多个编码方式，分别是UTF-8，UTF-16和UTF-32。 <br>
                        <a href="https://www.cnblogs.com/happyday56/p/4135845.html">参考资料</a>
                    </span>
                </li>
            </ul>
            <h4>[<span>+</span>] 字符编码</h4>
            <ul style="display:none">
                <li>
                    <a href="">ascii</a>
                    <span>
                        仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。
                    </span>
                </li>
                <li>
                    <a href="">latin1/binary</a>
                    <span>
                        一种把 Buffer 编码成一字节编码的字符串的方式 <br>
                        ISO-8859-1的别名
                    </span>
                </li>
                <li>
                    <a href="">utf8</a>
                    <span>
                        多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。
                    </span>
                </li>
                <li>
                    <a href="">utf16le/ucs2</a>
                    <span>
                        2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。
                    </span>
                </li>
                <li>
                    <a href="">base64</a>
                    <span>
                        MIME编码的一种
                    </span>
                </li>
                <li>
                    <a href="">hex</a>
                    <span>
                        将每个字节编码为两个十六进制字符
                    </span>
                </li>
            </ul>
            <h4>[<span>-</span>] Buffer类</h4>
            <ul>
                <li>
                    Buffer.<a href="">from</a>(str,[encoding])
                    <span>
                        返回一个被 string 的值初始化的新的 Buffer 实例
                    </span>
                </li>
                <li>
                    Buffer.<a href="">from</a>(buffer)
                    <span>
                        复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例
                    </span>
                </li>
                <li>
                    Buffer.<a href="">from</a>(array)
                    <span>
                        返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖）
                    </span>
                </li>
                <li>
                    Buffer.<a href="">from</a><em>(arrayBuffer,[byteOffset],[length])</em>
                    <span>
                        返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer <br>
                        <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer">参考资料</a>
                    </span>
                </li>
                <li>
                    Buffer.<a href="">alloc</a>(size,[fill],[encoding])
                    <span>
                        返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0
                        <ol>
                            <li>size - 新建的buffer期望的长度(>0,&lt;max)</li>
                            <li>fill - 用来预填充新建的Buffer值，默认0(str,buffer,integer)</li>
                            <li>encoding - 如果fill是字符串，则该值是它的字符编码，默认utf8</li>
                        </ol>
                    </span>
                </li>
                <li>
                    Buffer.<a href="">allocUnsafe</a>(size)
                    <span>
                        返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据
                    </span>
                </li>
                <li>
                    Buffer.<a href="">allocUnsafeSlow</a>(size)
                    <span>
                        以这种方式创建的 Buffer 实例的底层内存是未初始化的。 新创建的 Buffer 的内容是未知的，且可能包含敏感数据。  <br>
                        应当仅仅作为开发者已经在他们的应用程序中观察到过度的内存保留之后的终极手段使用。
                    </span>
                </li>
            </ul>
            <h4>[<span>+</span>] 属性</h4>
            <ul style="display:none">
                <li>
                    buf.<a href="">length</a>
                    <span>
                        返回 buf 在字节数上分配的内存量。 注意，这并不一定反映 buf 内可用的数据量。
                    </span>
                </li>
                <li>
                    Buffer.<a href="">byteLength</a>(str,[encoding])
                    <span>
                        返回一个字符串的实际字节长度。 <br>
                        当 string 是一个 Buffer/DataView/TypedArray/ArrayBuffer 时，返回实际的字节长度。
                    </span>
                </li>
                <li>
                    buf<a href="">[index]</a>
                    <span>
                        索引操作符 [index] 可用于获取或设置 buf 中指定 index 位置的八位字节。 <br>
                        这个值指向的是单个字节，所以合法的值范围是的 0x00 至 0xFF（十六进制），或 0 至 255（十进制）。
                    </span>
                </li>
                <li>
                    buf.<a href="">buffer</a>
                    <span>
                        buffer 属性指向创建该 Buffer 的底层的 ArrayBuffer 对象。
                    </span>
                </li>
                <li>
                    buf.<a href="">constants</a>
                    <span>
                        <table>
                            <tr>
                                <th>属性</th>
                                <th>描述</th>
                            </tr>
                            <tr>
                                <td>buffer.INSPECT_MAX_BYTES</td>
                                <td>当调用 buf.inspect() 时返回的最大字节数。 可以被用户模块重写。 </td>
                            </tr>
                            <tr>
                                <td>buffer.constants.MAX_LENGTH</td>
                                <td>单个Buffer实例允许的最大量度</td>
                            </tr>
                            <tr>
                                <td>buffer.constants.MAX_STRING_LENGTH</td>
                                <td>单个string实例允许的最大长度</td>
                            </tr>
                            <tr>
                                <td>buffer.kMaxLength</td>
                                <td>分配给单个 Buffer 实例的最大内存</td>
                            </tr>
                        </table>
                    </span>
                </li>
                <li>
                    Buffer.<a href="">poolSize</a>
                    <span>
                        这是用于决定预分配的、内部 Buffer 实例池的大小的字节数。 这个值可以修改。
                    </span>
                </li>
                <li>
                    Buffer.<a href="">isBuffer</a>(obj)
                    <span>
                        如果 obj 是一个 Buffer 则返回 true ，否则返回 false 。
                    </span>
                </li>
                <li>
                    Buffer.<a href="">isEncoding</a>(encoding)
                    <span>
                        如果 encoding 是一个支持的字符编码则返回 true，否则返回 false 。
                    </span>
                </li>
            </ul>
            <h4>[<span>-</span>] 读取/写入</h4>
            <ul>
                <li>
                    buf.<a href="">toString</a><em>([encoding],[n,m])</em>
                    <span>
                        根据 encoding 指定的字符编码解码 buf 成一个字符串。 start 和 end 可传入用于只解码 buf 的一部分。
                    </span>
                </li>
                <li>
                    buf.<a href="">write</a><em>(str,[offset],[length],[encoding])</em>
                    <span>
                        根据 encoding 的字符编码写入 string 到 buf 中的 offset 位置。 length 参数是写入的字节数。 如果 buf 没有足够的空间保存整个字符串，则只会写入 string 的一部分。 只部分解码的字符不会被写入。
                    </span>
                </li>
            </ul>
            <h4>[<span>-</span>] 修改</h4>
            <ul>
                <li>
                    buf.<a href="">fill</a><em>(val,[offset],[end],[encoding])</em>
                    <span>
                        填充一个buffer
                    </span>
                </li>
                <li>
                    buf.<a href="">slice</a>[n,m)
                    <span>
                        返回一个指向相同原始内存的新建的 Buffer，但做了偏移且通过 start 和 end 索引进行裁剪。 <br>
                        注意，修改这个新建的 Buffer 切片，也会同时修改原始的 Buffer 的内存，因为这两个对象所分配的内存是重叠的。 <br>
                        指定负的索引会导致切片的生成是相对于 buf 的末尾而不是开头。
                    </span>
                </li>
                <li>
                    Buffer.<a href="">concat</a>(list,[totalLength])
                    <span>
                        返回一个合并了 list 中所有 Buffer 实例的新建的 Buffer 。
                        <ol>
                            <li>list - 要合并的 Buffer 或 Uint8Array 实例的数组</li>
                            <li>totalLength - 合并时 list 中 Buffer 实例的总长度</li>
                        </ol>
                    </span>
                </li>
                <li>
                    buf.<a href="">copy</a>(target,[range])
                    <span>
                        贝 buf 的一个区域的数据到 target 的一个区域，即便 target 的内存区域与 buf 的重叠。
                    </span>
                </li>
            </ul>
            <h4>[<span>-</span>] 转换</h4>
            <ul>
                <li>
                    buf.<a href="">toJSON()</a>
                    <span>
                        返回 buf 的 JSON 格式。 <br>
                        {"type":"Buffer","data":[1,2,3,4,5]}
                    </span>
                </li>
                <li>
                    buf.<a href="">transcode</a><em>(source,from,to)</em>
                    <span>
                        将给定的 Buffer 或 Uint8Array 实例从一个字符编码重新编码到另一个字符。 返回一个新的Buffer实例。
                    </span>
                </li>
            </ul>
            <h4>[<span>-</span>] 检索</h4>
            <ul>
                <li>
                    buf.<a href="">includes</a><em>(val,[byteOffset],[encoding])</em>
                    <span>
                        检索一个buffer
                    </span>
                </li>
                <li>
                    buf.<a href="">indexOf</a><em>(val,[byteOffset],[encoding])</em>
                    <span>
                        查找一个值在buffer中的索引 <br>
                        如果 buf 没包含 value 则返回 -1
                    </span>
                </li>
                <li>
                    buf.<a href="">lastIndexOf</a><em>(val,[byteOffset],[encoding])</em>
                    <span>
                        与 buf.indexOf() 类似，除了 buf 是从后往前搜索而不是从前往后。
                    </span>
                </li>
            </ul>
            <h4>[<span>+</span>] 迭代器</h4>
            <ul style="display:none;">
                <li>
                    buf.<a href="">entries()</a>
                    <span>
                        从 buf 的内容中，创建并返回一个 [index, byte] 形式的迭代器
                    </span>
                </li>
                <li>
                    buf.<a href="">keys()</a>
                    <span>
                        创建并返回一个包含 buf 键名（索引）的迭代器。
                    </span>
                </li>
                <li>
                    buf.<a href="">values()</a>
                    <span>
                        创建并返回一个包含 buf 的值（字节）的迭代器。 当 Buffer 使用 for..of 时会自动调用该函数。
                    </span>
                </li>
            </ul>
            <h4>[<span>+</span>] 比较</h4>
            <ul style="display:none;">
                <li>
                    buf.<a href="">compare</a>(target,[range])
                    <span>
                        比较 buf 与 target，返回表明 buf 在排序上是否排在 target 之前、或之后、或相同。 对比是基于各自 Buffer 实际的字节序列。 <hr>
                        如果 target 与 buf 相同，则返回 0 。 <br>
                        如果 target 排在 buf 前面，则返回 1 。<br>
                        如果 target 排在 buf 后面，则返回 -1 。
                    </span>
                </li>
                <li>
                    Buffer.<a href="">compare</a>(buf1,buf2)
                    <span>
                        比较 buf1 和 buf2 ，通常用于 Buffer 实例数组的排序。
                    </span>
                </li>
                <li>
                    buf.<a href="">equals</a>(buffer)
                    <span>
                        如果 buf 与 otherBuffer 具有完全相同的字节，则返回 true，否则返回 false。
                    </span>
                </li>
            </ul>
            <h4>[<span>+</span>] 读取</h4>
            <ul style="display:none;">
                <li>
                    buf.<a href="">readDoubleBE</a><em>(offset,[noAssert])</em>
                    <span>
                        用指定的字节序格式（readDoubleBE() 返回大端序，readDoubleLE() 返回小端序）从 buf 中指定的 offset 读取一个64位双精度值。
                    </span>
                </li>
                <li>
                    buf.<a href="">readFloatBE</a><em>(offset,[noAssert])</em>
                    <span>
                        用指定的字节序格式（readFloatBE() 返回大端序，readFloatLE() 返回小端序）从 buf 中指定的 offset 读取一个32位浮点值。
                    </span>
                </li>
                <li>
                    buf.<a href="">readInt8</a><em>(offset,[noAssert])</em>
                    <span>
                        从 buf 中指定的 offset 读取一个有符号的8位整数值。
                    </span>
                </li>
                <li>
                    buf.<a href="">readInt16BE</a><em>(offset,[noAssert])</em>
                    <span>
                        用指定的字节序格式（readInt16BE() 返回大端序，readInt16LE() 返回小端序）从 buf 中指定的 offset 读取一个有符号的16位整数值。
                    </span>
                </li>
                <li>
                    buf.<a href="">readInt32BE</a><em>(offset,[noAssert])</em>
                    <span>
                        用指定的字节序格式（readInt32BE() 返回大端序，readInt32LE() 返回小端序）从 buf 中指定的 offset 读取一个有符号的32位整数值。
                    </span>
                </li>
                <li>
                    buf.<a href="">readIntBE</a><em>(offset,byteLength,[noAssert])</em>
                    <span>
                        从 buf 中指定的 offset 读取 byteLength 个字节，且读取的值会被解析为二进制补码值。 最高支持48位精度。
                    </span>
                </li>
                <li>
                    buf.<a href="">readUInt8</a><em>(offset,[noAssert])</em>
                    <span>
                        从 buf 中指定的 offset 读取一个无符号的8位整数值。
                    </span>
                </li>
                <li>
                    buf.<a href="">readUInt16BE</a><em>(offset,[noAssert])</em>
                    <span>
                        用指定的字节序格式（readUInt16BE() 返回大端序，readUInt16LE() 返回小端序）从 buf 中指定的 offset 读取一个无符号的16位整数值。
                    </span>
                </li>
                <li>
                    buf.<a href="">readUInt32BE</a><em>(offset,[noAssert])</em>
                    <span>
                        用指定的字节序格式（readUInt32BE() 返回大端序，readUInt32LE() 返回小端序）从 buf 中指定的 offset 读取一个无符号的32位整数值。
                    </span>
                </li>
                <li>
                    buf.<a href="">readUIntBE</a><em>(offset,byteLength,[noAssert])</em>
                    <span>
                        从 buf 中指定的 offset 读取 byteLength 个字节，且读取的值会被解析为无符号的整数。 最高支持48位精度。
                    </span>
                </li>
            </ul>
            <h4>[<span>+</span>] 交换</h4>
            <ul style="display:none;">
                <li>
                    buf.<a href="">swap16()</a>
                    <span>
                        将 buf 解析为一个无符号16位的整数数组，并且以字节顺序原地进行交换。 如果 buf.length 不是2的倍数，则抛出 RangeError 错误。
                    </span>
                </li>
                <li>
                    buf.<a href="">swap32()</a>
                    <span>
                        将 buf 解析为一个无符号32位的整数数组，并且以字节顺序原地进行交换。 如果 buf.length 不是4的倍数，则抛出 RangeError 错误。
                    </span>
                </li>
                <li>
                    buf.<a href="">swap64()</a>
                    <span>
                        将 buf 解析为一个64位的数值数组，并且以字节顺序原地进行交换。 如果 buf.length 不是8的倍数，则抛出 RangeError 错误。
                    </span>
                </li>
            </ul>
        </div>
    </div>
    <div class="u-block">
        <h3>string_decoder<span>-</span></h3>
        <div class="u-list">
            <h4>[<span>-</span>] 字符串解码器</h4>
            <ul>
                <li>
                    <a href="">string_decoder</a>
                    <span>
                        string_decoder 模块提供了一个 API，用于把 Buffer 对象解码成字符串，但会保留编码过的多字节 UTF-8 与 UTF-16 字符。 <hr>
                        const {StringDecoder} = require('string_decoder') <br>
                        const decoder = new StringDecoder('utf8')
                    </span>
                </li>
                <li>
                    string_decoder.<a href="">write</a>(buffer)
                    <span>
                        返回一个解码后的字符串，并确保返回的字符串不包含 Buffer 末尾残缺的多字节字符，残缺的多字节字符会被保存在一个内部的 buffer 中用于下次调用
                    </span>
                </li>
                <li>
                    string_decoder.<a href="">end</a>([buffer])
                    <span>
                        以字符串的形式返回内部 buffer 中剩余的字节。 残缺的 UTF-8 与 UTF-16 字符的字节会被替换成符合字符编码的字符。
                    </span>
                </li>
            </ul>
        </div>
    </div>
    <div class="u-block">
        <h3>crypto<span>-</span></h3>
        <div class="u-list">
            <h4>[<span>-</span>] 加密</h4>
        </div>
    </div>
</div>

