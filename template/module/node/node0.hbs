<!-- 全局对象、事件 -->
<div class="u-col">
    <div class="u-block">
        <h3>global<span>-</span></h3>
        <div class="u-list">
            <h4>[<span>-</span>] global变量</h4>
            <ul>
                <li>
                    <a href="">global</a>
                    <span>
                        全局对象
                    </span>
                </li>
                <li>
                    <a href="">module</a>
                    <span>
                        对当前模块的引用 <br>
                        全局变量在所有模块中均可使用，但以下变量的作用域只在模块内
                    </span>
                </li>
                <li>
                    <a href="">__filename</a>
                    <span>
                        当前正在执行的脚本的文件名，它将输出文件所在位置的绝对路径 <br>
                        如果在模块中，返回的值是模块文件的路径。
                    </span>
                </li>
                <li>
                    <a href="">__dirname</a>
                    <span>
                        表示当前执行脚本所在的目录
                    </span>
                </li>
                <li>
                    <a href="">exports</a>
                    <span>
                        这是一个对于 module.exports 的更简短的引用形式 <br>
                        如果一个新的值被赋值给 exports，它就不再绑定到 module.exports <br>
                        但如果是对exports.prop进行赋值，则依然当做module.exports.prop输出 <br>
                        当 module.exports 属性被一个新的对象完全替代时，也会重新赋值 exports
                    </span>
                </li>
                <li>
                    <a href="">require</a>(mod)
                    <span>
                        引入模块 <br>
                        缓存 > 原生模块 > 文件模块 > node_modules > 全局目录
                    </span>
                </li>
            </ul>
            <h4>[<span>+</span>] module对象</h4>
            <ul style="display:none;">
                <li>
                    module.<a href="">exports</a>
                    <span>
                        模块对外输出 <br>
                        单个函数输出，需要 module.exports = fn(){} <br>
                        作为对象输出，可以exports.prop = fn(){} <br>
                        或者 module.exports = $obj
                    </span>
                </li>
                <li>
                    module.<a href="">children</a>
                    <span>
                        被该模块引用的模块对象，返回数组 <br>
                        不会包括内置对象
                    </span>
                </li>
                <li>
                    module.<a href="">parent</a>
                    <span>
                        最先引用该模块的模块
                    </span>
                </li>
                <li>
                    module.<a href="">id</a>
                    <span>
                        模块的标识符。 通常是完全解析后的文件名 <br>
                        被引入的模块，同__filename
                    </span>
                </li>
                <li>
                    module.<a href="">filename</a>
                    <span>
                        模块的完全解析后的文件名
                    </span>
                </li>
                <li>
                    module.<a href="">loaded</a>
                    <span>
                        模块是否已经加载完成，或正在加载中
                    </span>
                </li>
                <li>
                    module.<a href="">paths</a>
                    <span>
                        模块的搜索路径,返回数组
                    </span>
                </li>
                <li>
                    require.<a href="">cache</a>
                    <span>
                        被引入的模块将被缓存在这个对象中。从此对象中删除键值对将会导致下一次 require 重新加载被删除的模块。
                    </span>
                </li>
                <li>
                    require.<a href="">main</a>
                    <span>
                        当 Node.js 直接运行一个文件时，require.main 会被设为它的 module。 这意味着可以通过 require.main === module 来判断一个文件是否被直接运行 <br>
                        通过检查 require.main.filename 来获取当前应用程序的入口点
                    </span>
                </li>
            </ul>
            <h4>[<span>-</span>] timers</h4>
            <ul>
                <li>
                    <a href="">setImmediate</a>(fn,[arg])
                    <span>
                        预定立即执行的 callback，它是在 I/O 事件的回调之后被触发。 <br>
                        当多次调用 setImmediate() 时，callback 函数会按照它们被创建的顺序依次执行。 每次事件循环迭代都会处理整个回调队列。 如果一个立即定时器是被一个正在执行的回调排入队列的，则该定时器直到下一次事件循环迭代才会被触发。
                    </span>
                </li>
                <li>
                    <a href="">clearImmediate</a>(immediate)
                    <span>
                        取消一个由 setImmediate() 创建的 Immediate 对象。
                    </span>
                </li>
                <li>
                    <a href="">setInterval</a>(fn,delay,[arg])
                    <span>
                        预定每隔 delay 毫秒重复执行的 callback。
                    </span>
                </li>
                <li>
                    <a href="">clearInterval</a>(timeout)
                    <span>
                        取消一个由 setInterval() 创建的 Timeout 对象。
                    </span>
                </li>
                <li>
                    <a href="">setTimeout</a>(fn,delay,[arg])
                    <span>
                        预定在 delay 毫秒之后执行的单次 callback。
                    </span>
                </li>
                <li>
                    <a href="">clearTimeout</a>(timeout)
                    <span>
                        取消一个由 setTimeout() 创建的 Timeout 对象。
                    </span>
                </li>
                <li>
                    <a href="">timeout.ref()</a>
                    <span>
                        调用时，只要 Timeout 处于活动状态就要求 Node.js 事件循环不要退出。<br>
                        返回 Timeout 的一个引用。
                    </span>
                </li>
                <li>
                    <a href="">timeout.unref()</a>
                    <span>
                        当调用时，活动的 Timeout 对象不要求 Node.js 事件循环保持活动。 <br>
                        返回对 Timeout 的一个引用。
                    </span>
                </li>
            </ul>
            <h4>[<span>+</span>] console</h4>
            <ul style="display:none;">
                <li>
                    <a href="">new Console</a>(stdout,[stderr])
                    <span>
                        通过传入一个或两个可写流实例，创建一个新的 Console 对象。 stdout 是一个可写流，用于打印日志或输出信息。 stderr 用于输出警告或错误。 如果没有传入 stderr ，则警告或错误输出会被发送到 stdout 。
                    </span>
                </li>
                <li>
                    console.<a href="">log/info</a>([data,..])
                    <span>
                        打印到 stdout，并带上换行符。
                    </span>
                </li>
                <li>
                    console.<a href="">error/warn</a>([data,..])
                    <span>
                        打印到 stderr，并带上换行符。 
                    </span>
                </li>
                <li>
                    console.<a href="">dir</a>(obj,[opt])
                    <span>
                        在 obj 上使用 util.inspect() 并打印结果字符串到 stdout。  <hr>
                        showHidden - 如果为 true，则该对象中的不可枚举属性和 symbol 属性也会显示。默认为 false。 <br>
                        depth - 告诉 util.inspect() 函数当格式化对象时要递归多少次。 这对于检查较大的复杂对象很有用。 默认为 2。 设为 null 可无限递归。<br>
                        colors - 如果为 true，则输出会带有 ANSI 颜色代码。 默认为 false。 颜色是可定制的，详见定制 util.inspect() 颜色。
                    </span>
                </li>
                <li>
                    console.<a href="">time</a>(label)
                    <span>
                        启动一个定时器，用以计算一个操作的持续时间。 定时器由一个唯一的 label 标识。 当调用 console.timeEnd() 时，可以使用相同的 label 来停止定时器，并以毫秒为单位将持续时间输出到 stdout。 定时器持续时间精确到亚毫秒。
                    </span>
                </li>
                <li>
                    console.<a href="">timeEnd</a>(label)
                    <span>
                        停止之前通过调用 console.time() 启动的定时器，并打印结果到 stdout
                    </span>
                </li>
                <li>
                    console.<a href="">count</a>([label])
                    <span>
                        维护一个指定 label 的内部计数器并且输出到 stdout 指定 label 调用 console.count() 的次数。label计数器的显示标签，默认为 'default'。
                    </span>
                </li>
                <li>
                    console.<a href="">countRest</a>([label])
                    <span>
                        重置指定 label 的内部计数器。
                    </span>
                </li>
                <li>
                    console.<a href="">group</a>([label])
                    <span>
                        将后续行的缩进增加两个空格。
                    </span>
                </li>
                <li>
                    console.<a href="">groupEnd()</a>
                    <span>
                        将后续行的缩进减少两个空格。
                    </span>
                </li>
                <li>
                    console.<a href="">clear()</a>
                    <span>
                        当 stdout 是一个 TTY 时，调用 console.clear() 将尝试清除 TTY。 当 stdout 不是一个TTY时，该方法什么都不做。
                    </span>
                </li>
                <li>
                    console.<a href="">assert</a>(val,[msg,..])
                    <span>
                        一个简单的断言测试，验证 value 是否为真。 如果不为真，则抛出 AssertionError。
                    </span>
                </li>
                <li>
                    console.<a href="">trace</a>([msg,..])
                    <span>
                        打印字符串 'Trace :' 到 stderr ，并通过 util.format() 格式化消息与堆栈跟踪在代码中的当前位置。
                    </span>
                </li>
            </ul>
        </div>
    </div>
    <div class="u-block">
        <h3>events<span>-</span></h3>
        <div class="u-list">
            <h4>[<span>+</span>] EventEmitter类</h4>
            <ul style="display:none;">
                <li>
                    <a href="">var EventEmitter = require('events')</a>
                    <span>
                        引入events模块，得到EventEmitter类
                    </span>
                </li>
                <li>
                    <a href="">class $EMT extends EventEmitter {}</a>
                    <span>
                        需要监听事件的对象，继承事件对象 <br>
                        大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。
                    </span>
                </li>
                <li>
                    <a href="">var evt = new $EMT()</a>
                    <span>
                        创建一个EventEmitter 实例
                    </span>
                </li>
            </ul>
            <h4>[<span>-</span>] 添加/移除/触发监听器</h4>
            <ul>
                <li>
                    eet.<a href="">on</a>(evt,listener)
                    <span>
                        绑定事件及事件处理程序 <br>
                        也可以写作eet.addListener(evt,fn) <br>
                        一个事件可以有多个监听器，但参数应是一致的，否则应作为多个事件处理
                        <hr>
                        返回值：返回一个 EventEmitter 引用，可以链式调用。
                    </span>
                </li>
                <li>
                    eet.<a href="">prependListener</a>(evt,listener)
                    <span>
                        添加 listener 函数到名为 eventName 的事件的监听器数组的开头。 <br>
                        不会检查 listener 是否已被添加。 多次调用并传入相同的 eventName 和 listener 会导致 listener 被添加与调用多次。
                        <hr>
                        返回值：返回一个 EventEmitter 引用，可以链式调用。
                    </span>
                </li>
                <li>
                    eet.<a href="">once</a>(evt,listener)
                    <span>
                        为指定事件注册一个单次监听器，即监听器最多只会触发一次，触发后立刻解除该监听器。 <hr>
                        返回值：返回一个 EventEmitter 引用，可以链式调用。
                    </span>
                </li>
                <li>
                    eet.<a href="">prependOnceListener</a>(evt,listener)
                    <span>
                        添加一个单次 listener 函数到名为 eventName 的事件的监听器数组的开头。 <br> 下次触发 eventName 事件时，监听器会被移除，然后调用。
                        <hr>
                        返回值：返回一个 EventEmitter 引用，可以链式调用。
                    </span>
                </li>
                <li>
                    eet.<a href="">removeListener</a>(evt,listener)
                    <span>
                        移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。 <br>
                        removeListener 最多只会从监听器数组里移除一个监听器实例。 如果任何单一的监听器被多次添加到指定 eventName 的监听器数组中，则必须多次调用 removeListener 才能移除每个实例。 <hr>
                        返回值：返回一个 EventEmitter 引用，可以链式调用。
                    </span>
                </li>
                <li>
                    eet.<a href="">removeAllListeners</a>([evt])
                    <span>
                        移除全部或指定 eventName 的监听器。 <hr>
                        返回值：返回一个 EventEmitter 引用，可以链式调用。
                    </span>
                </li>
                <li>
                    eet.<a href="">emit</a>(evt,[arg])
                    <span>
                        触发事件 <br>
                        arg为监听器回调函数传入的参数，同一个事件下的监听器应使用同样的参数 <hr>
                        返回值：布尔值，如果事件有监听器，则返回 true ，否则返回 false。
                    </span>
                </li>
            </ul>
            <h4>[<span>+</span>] 内置事件</h4>
            <ul style="display:none;">
                <li>
                    [evt]<a href="">newListener</a>
                    <span>
                        EventEmitter 实例会在一个监听器被添加到其内部监听器数组之前触发自身的 'newListener' 事件。
                    </span>
                </li>
                <li>
                    [evt]<a href="">removeListener</a>
                    <span>
                        'removeListener' 事件在 listener 被移除后触发。
                    </span>
                </li>
                <li>
                    [evt]<a href="">error</a>
                    <span>
                        我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。
                    </span>
                </li>
            </ul>
            <h4>[<span>+</span>] 其它属性/方法</h4>
            <ul style="display:none;">
                <li>
                    eet.<a href="">eventNames()</a>
                    <span>
                        列出触发器上所有绑定的事件，返回一个数组。
                    </span>
                </li>
                <li>
                    eet.<a href="">getMaxListeners()</a>
                    <span>
                        返回 EventEmitter 当前的最大监听器限制值，默认10
                    </span>
                </li>
                <li>
                    eet.<a href="">setMaxListeners</a>(n)
                    <span>
                        值设为 Infinity（或 0）表明不限制监听器的数量。 <br>
                        返回值：返回一个 EventEmitter 引用，可以链式调用。
                    </span>
                </li>
                <li>
                    eet.<a href="">listenerCount</a>(evt)
                    <span>
                        返回指定事件的监听器的数量
                    </span>
                </li>
                <li>
                    eet.<a href="">listeners</a>(evt)
                    <span>
                        返回指定事件的监听器数组的副本
                    </span>
                </li>
            </ul>
        </div>
    </div>
</div>