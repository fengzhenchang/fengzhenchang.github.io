<!-- 函数 -->
<div class="u-col">
	<div class="u-block">
		<h3>对象<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>+</span>] 构建</h4>
			<ul style="display:none;">
				<li>
					<a href="">{key:val,[$key]:val...}</a>
					<span>
						字面量创建方法 <br>
						对象有时也被叫作关联数组。对象的属性之间用逗号分隔，最后一个属性后面可以加逗号，也可以不加。 <br>
						对象的所有键名都是字符串，可以不加引号。但如果不符合表示名的条件，则需要加引号。<a href="http://javascript.ruanyifeng.com/grammar/object.html">参考资料</a> <hr>
						如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。 <br>
						但如果取消某一个变量对于原对象的引用，不会影响到另一个变量。 <br>
						这种引用只局限于对象，对于原始类型的数据则是传值引用，也就是说，都是值的拷贝。 <br>
						故在设置一个新的对象继承旧对象时，不能直接通过new.prototype = old.prototype进行设置，否则对new原型的任何修改，将直接会影响旧的原型对象。
						<hr>
						如果行首是大括号，一律解释为语句（即代码块）。如果要解释为表达式（即对象），必须在大括号前加上圆括号。 <hr>
						如果读取一个不存在的键，会返回undefined，而不是报错。 <br>
						但不能对一个未声明的对象直接指定属性，这样会报错 
					</span>
				</li>
				<li>
					<a href="">new </a>Fn()
					<span>
						用构造函数创建 <br>
						<pre><code data-language="javascript">
							function Obj(opts){
								this.key = value
							}
							var o = new Obj(opts)
						</code></pre>
						new命令总是返回一个对象，要么是实例对象，要么是return语句指定的对象。 <br>
						new 构造函数时，this指向新创建的对象，并默认返回this，也就是说，不需要在最后写return this<br>
						函数内部可以使用new.target属性。如果当前函数是new命令调用，new.target指向当前函数，否则为undefined
					</span>
				</li>
				<li>
					<a href="">new Object()</a>
					<span>
						var obj = new Object(); <br>
						var obj = Object.creat(Object.prototype) <hr>
						obj.key = value; <br>
						从Object原型创建
					</span>
				</li>
			</ul>
			<h4>[<span>+</span>] 属性表示</h4>
			<ul style="display:none;">
				<li>
					obj.<a href="">key</a>
					<span>
						一个对象的属性可以被解释成一个附加到对象上的变量，使用.表示法时必须是一个合法的标识符 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Property_Accessors">参考资料</a>
					</span>
				</li>
				<li>
					obj<a href="">['key']</a>
					<span>
						对象的属性也可以通过方括号访问或者设置，对象有时也被叫作关联数组, 因为每个属性都有一个用于访问它的字符串值。<br> 
						一个对象的属性名可以是任何有效的 JavaScript 字符串，或者可以被转换为字符串的任何类型，包括空字符串。<br>
						当属性含空格、关键字时，只能用中括号表示
					</span>
				</li>
				<li>
					obj<a href="">[$key]</a>
					<span>
						当属性为变量时，只能用中括号表示
					</span>
				</li>
			</ul>
			<h4>[<span>-</span>] 属性设置</h4>
			<ul>
				<li>
					{<a href="">key:val</a>}
					<span>
						定义一个属性，值可以为任意类型 <br>
						对于一个已经存在的对象，可用obj.key = val 来进行设置
					</span>
				</li>
				<li>
					{<a href="">get|set key([x]){}</a>}
					<span>
						使用对象初始化器定义getter/setter方法 <br>
						getter方法必须是无参数的，setter方法只接受一个参数 <br>
						对于已经存在的对象，则需使用Object.defineProperties
					</span>
				</li>
				<li>
					<a href="">Object.defineProperty</a><em>(obj,key,desc)</em>
					<span>
						在一个对象上定义一个新属性或者修改现有属性， 并返回这个对象。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">参考资料</a>
					</span>
				</li>
				<li>
					<a href="">Object.defineProperties</a><em>(obj,{key:{desc}})</em>
					<span>
						在一个对象上定义新的属性或修改现有属性， 并返回这个对象。
						<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties">参考资料</a>
					</span>
				</li>
				<li>
					<a href="">delete </a>obj.key
					<span>
						delete 操作符删除一个不是继承而来的属性 <br>
						删除成功后返回true，注意，删除一个不存在的属性，delete不报错，而且返回true。 <br>
						只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。
					</span>
				</li>
			</ul>
			<h4>[<span>+</span>] 属性描述对象</h4>
			<ul style="display:none;">
				<li>
					<a href="">Object.getOwnPropertyDescriptor</a><em>(obj,key)</em>
					<span>
						返回指定对象上一个自有属性对应的属性描述符。
						<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor">参考资料</a> <br>
						注意，Object.getOwnPropertyDescriptor方法只能用于对象自身的属性，不能用于继承的属性
					</span>
				</li>
				<li>
					<a href="">Object.getOwnPropertyDescriptors</a><em>(obj)</em>
					<span>
						获取一个对象的所有自身属性的描述符 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors">参考资料</a>
					</span>
				</li>
				<li>
					<a href="">configurable</a>
					<span>
						false|true <br>
						表示该属性的描述对象是否可以修改(属性是否可被删除)。<br>
						数据描述符和存取描述符均具有此键值
					</span>
				</li>
				<li>
					<a href="">enumerable</a>
					<span>
						false|true  <br>
						表示该属性是否可枚举 <br>
						数据描述符和存取描述符均具有此键值
					</span>
				</li>
				<li>
					<a href="">value</a>
					<span>
						undefined|val <br>
						该属性对应的值<br>
						数据描述符具有此键值
					</span>
				</li>
				<li>
					<a href="">writable</a>
					<span>
						false|true	<br>
						表示属性值是否可改变 <br>
						数据描述符具有此键值
					</span>
				</li>
				<li>
					<a href="">get</a>
					<span>
						undefined|fn <br>
						存放一个函数，表示该属性的取值函数（getter）<br>
						存取描述符具有此键值
					</span>
				</li>
				<li>
					<a href="">set</a>
					<span>
						undefined|fn <br>
						存放一个函数，表示该属性的存值函数（setter）<br>
						存取描述符具有此键值
					</span>
				</li>
			</ul>
			<h4>[<span>-</span>] 属性判断</h4>
			<ul>
				<li>
					obj.<a href="">hasOwnProperty</a>(key)
					<span>
						检测对象是否拥有某一属性（非原型继承） <br>
						返回值：布尔
					</span>
				</li>
				<li>
					obj.<a href="">propertyIsEnumerable</a>(key)
					<span>
						判断某个属性是否可枚举
					</span>
				</li>
			</ul>
			<h4>[<span>-</span>] 属性枚举</h4>
			<ul>
				<li>
					<a href="">for $key in</a> obj
					<span>
						依次访问一个 [对象及其原型链] 中所有 [可枚举的属性]
					</span>
				</li>
				<li>
					<a href="">Object.keys</a>(obj)
					<span>
						返回 [对象] 自身（不包括原型中）的所有 [可枚举的属性] 的数组
					</span>
				</li>
				<li>
					<a href="">Object.getOwnPropertyNames</a><em>(obj)</em>
					<span>
						返回 [对象] 自身（不包括继承的）的所有 [属性] 的数组
					</span>
				</li>
				<li>
					<a href="">Object.getOwnPropertySymbols</a>(obj)
					<span>
						返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。
					</span>
				</li>
				<li>
					<a href="">Reflect.ownKeys</a>(obj)
					<span>
						返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。 <hr>
						<a href="http://es6.ruanyifeng.com/#docs/object#属性的遍历">参考资料</a> <br>
						首先遍历所有数值键，按照数值升序排列。<br>
						其次遍历所有字符串键，按照加入时间升序排列。<br>
						最后遍历所有 Symbol 键，按照加入时间升序排列。<br>
					</span>
				</li>
			</ul>
			<h4>[<span>+</span>] 状态控制</h4>
			<ul style="display:none;">
				<li>
					<a href="">Object.preventExtensions</a>(obj)
					<span>
						防止对象扩展
					</span>
				</li>
				<li>
					<a href="">Object.isExtensible</a>(obj)
					<span>
						判断对象是否可扩展
					</span>
				</li>
				<li>
					<a href="">Object.seal</a>(obj)
					<span>
						禁止对象配置，既无法添加新属性，也无法删除旧属性，但并不影响修改某个属性的值
					</span>
				</li>
				<li>
					<a href="">Object.isSealed</a>(obj)
					<span>
						判断一个对象是否可配置
					</span>
				</li>
				<li>
					<a href="">Object.freeze</a>(obj)
					<span>
						冻结一个对象，无法添加新属性、无法删除旧属性、也无法改变属性的值 <br>	
						冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。
					</span>
				</li>
				<li>
					<a href="">Object.isFrozen</a>(obj)
					<span>
						判断一个对象是否被冻结
					</span>
				</li>
			</ul>
			<h4>[<span>+</span>] 其它</h4>
			<ul>
				<li>
					<a href="">Object.values</a>(obj)
					<span>
						返回一个对象的值的数组
					</span>
				</li>
				<li>
					<a href="">Object.entries</a>(obj)
					<span>
						返回一个对象的键值的二维数组
					</span>
				</li>
				<li>
					<a href="">Object.assign</a>(to,from...)
					<span>
						将所有可枚举属性的值从一个或多个源对象复制到目标对象，将返回目标对象。<br>
						1.浅拷贝，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用 <br>
						2.只会拷贝源对象自身的并且可枚举的属性到目标对象 <br> 
						Object.assign 不会跳过那些值为 null 或 undefined 的源对象 <br>
						<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">参考资料</a>
						<hr>
					</span>
				</li>
				<li>
					<a href="">Object.is</a>(x,y)
					<span>
						判断两个值是否全等（必须引用地址也一致）
					</span>
				</li>
				<li>
					obj.<a href="">toString</a>()
					<span>
						可通过自定义toString方法替换原型的返回值。  <br>
						Object.prototype.toString.call(value) 可判断其构造函数：
						<table>
							<tr>
								<th>value</th>
								<th>返回值</th>
							</tr>
							<tr>
								<td>数值</td>
								<td>[object Number]</td>
							</tr>
							<tr>
								<td>字符串</td>
								<td>[object String]</td>
							</tr>
							<tr>
								<td>布尔值</td>
								<td>[object Boolean]</td>
							</tr>
							<tr>
								<td>undefined</td>
								<td>[object Undefined]</td>
							</tr>
							<tr>
								<td>null</td>
								<td>[object Null]</td>
							</tr>
							<tr>
								<td>数组</td>
								<td>[object Array]</td>
							</tr>
							<tr>
								<td>arguments对象</td>
								<td>[object Arguments]</td>
							</tr>
							<tr>
								<td>函数</td>
								<td>[object Function]</td>
							</tr>
							<tr>
								<td>Error对象</td>
								<td>[object Error]</td>
							</tr>
							<tr>
								<td>Date对象</td>
								<td>[object Date]</td>
							</tr>
							<tr>
								<td>RegExp对象</td>
								<td>[object RegExp]</td>
							</tr>
							<tr>
								<td>其他对象</td>
								<td>[object Object]</td>
							</tr>
						</table>
					</span>
				</li>
				<li>
					obj.<a href="">valueOf</a>()
					<span>
						返回指定对象的原始值 <br>
						<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf">参考资料</a>
					</span>
				</li>
			</ul>
		</div>
	</div>
	<div class="u-block">
        <h3>元编程<span>-</span></h3>
        <div class="u-list">
            <h4>[<span>+</span>] Symbol</h4>
            <ul style="display:none;">
                <li>
                    <a href="">Symbol</a>([des])
                    <span>
                        它是一种类似于字符串的数据类型，但独一无二。 <hr>
                        1.Symbol函数前不能使用new命令，否则会报错 <br>
                        2.Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。 <br>
                        3.Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。 <br>
                        4.Symbol 值不能与其他类型的值进行运算 <br>
                        5.Symbol 值可以通过toString或String方法显式转为字符串 <br>
                        6.Symbol 值也可以转为布尔值，但是不能转为数值 <br>
                        7.不能使用.运算符，必须使用[] <br>
                        8.Symbol 作为属性名，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。
                    </span>
                </li>
                <li>
                    <a href="">Symbol.for</a>(desc)
                    <span>
                        接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。
                    </span>
                </li>
                <li>
                    <a href="">Symbol.keyfor</a>(symbol)
                    <span>
                        返回一个已登记的 Symbol 类型值的key
                    </span>
                </li>
            </ul>
			<h4>[<span>-</span>] Proxy</h4>
			<ul>
				<li>
					<a href="">new Proxy</a>(target,handler)
					<span>
                        var proxy = new Proxy(target,{handler}) <br>
						在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。 <br>
						<a href="http://es6.ruanyifeng.com/#docs/proxy">参考资料</a> <br>
						通过改写return值，可实现链式操作 <hr>
                        当被代理的对象为不同的类型时：<br>
                        对象：target=源对象,key=源对象的属性;<br>
                        数组：target=源数组,key=源数组的索引;<br>
                        函数：target=执行源函数,target[key]=函数源; <br>
					</span>
				</li>
                <li>
					<a href="">Proxy.revocable</a>(target,handler)
					<span>
						返回一个可取消的Proxy实例 <br>
                        let {proxy, revoke} = Proxy.revocable(target, handler); <br>
                        目标对象内部的this关键字会指向 Proxy 代理 <br>
                        Proxy.revocable方法返回一个对象，该对象的proxy属性是Proxy实例，revoke属性是一个函数，可以取消Proxy实例 <a href="http://es6.ruanyifeng.com/#docs/proxy#Proxy-revocable">参考资料</a>
					</span>
				</li>
				<li>
					handler.<a href="">get</a><em>(target,key,receiver)</em>
					<span>
						拦截对象属性的读取
					</span>
				</li>
				<li>
					handler.<a href="">set</a><em>(target,key,val,receiver)</em>
					<span>
						拦截对象属性的设置
					</span>
				</li>
				<li>
					handler.<a href="">has</a><em>(target,key)</em>
					<span>
						拦截propKey in proxy的操作，返回一个布尔值。
					</span>
				</li>
				<li>
					handler.<a href="">deleteProperty</a><em>(target,key)</em>
					<span>
						拦截delete proxy[propKey]的操作，返回一个布尔值。
					</span>
				</li>
                <li>	
					handler.<a href="">construct</a><em>(target, args)</em>
					<span>
						拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。
					</span>
				</li>
                <li>
					handler.<a href="">apply</a><em>(target,object,args)</em>
					<span>
						拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。
					</span>
				</li>
				<li>
					handler.<a href="">ownKeys</a><em>(target)</em>
					<span>
						拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。该方法返回目标对象所有自身的属性的属性名。
					</span>
				</li>
                <li>
					handler.<a href="">getOwnPropertyDescriptor</a><em>(target,key)</em>
					<span>
						拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。
					</span>
				</li>
				<li>
					handler.<a href="">defineProperty</a><em>(target,key,desc)</em>
					<span>
						拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。
					</span>
				</li>
				<li>
					handler.<a href="">preventExtensions</a><em>(target)</em>
					<span>
						拦截Object.preventExtensions(proxy)，返回一个布尔值。
					</span>
				</li>
                <li>
					handler.<a href="">isExtensible</a><em>(target)</em>
					<span>
						拦截Object.isExtensible(proxy)，返回一个布尔值。
					</span>
				</li>
				<li>
					handler.<a href="">getPrototypeOf</a><em>(target)</em>
					<span>
						拦截Object.getPrototypeOf(proxy)，返回一个对象。
					</span>
				</li>
				<li>
					handler.<a href="">setPrototypeOf</a><em>(target,proto)</em>
					<span>
						拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。
					</span>
				</li>
			</ul>
			<h4>[<span>+</span>] Reflect</h4>
			<ul style="display:none;">
				<li>
					<a href="">Reflect</a>
					<span>
						1.将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。 <br>
						2.修改某些Object方法的返回结果，让其变得更合理。 <br>
						3.让Object操作都变成函数行为。 <br>
						<a href="http://es6.ruanyifeng.com/#docs/reflect">参考资料</a>
					</span>
				</li>
				<li>
					Reflect.<a href="">get</a><em>(target,key,[receiver])</em>
					<span>
						查找并返回target对象的name属性，如果没有该属性，则返回undefined。
					</span>
				</li>
				<li>
					Reflect.<a href="">set</a><em>(target,key,value,[receiver])</em>
					<span>
						设置target对象的name属性等于value
					</span>
				</li>
				<li>
					Reflect.<a href="">has</a><em>(target,key)</em>
					<span>
						对应key in obj里面的in运算符
					</span>
				</li>
				<li>
					Reflect.<a href="">deleteProperty</a><em>(target,key)</em>
					<span>
						等同于delete obj[name]，用于删除对象的属性
					</span>
				</li>
				<li>
					Reflect.<a href="">construct</a><em>(target,args)</em>
					<span>
						等同于new target(...args)，这提供了一种不使用new，来调用构造函数的方法。
					</span>
				</li>
                <li>
					Reflect.<a href="">apply</a><em>(fn,thisArg,args)</em>
					<span>
						等同于Function.prototype.apply.call(func, thisArg, args)，用于绑定this对象后执行给定函数。
					</span>
				</li>
                <li>
					Reflect.<a href="">ownKeys</a><em>(target)</em>
					<span>
						返回对象的所有属性，基本等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和。
					</span>
				</li>
                <li>
					Reflect.<a href="">getOwnPropertyDescriptor</a><em>(target,key)</em>
					<span>
						基本等同于Object.getOwnPropertyDescriptor，用于得到指定属性的描述对象
					</span>
				</li>
				<li>
					Reflect.<a href="">defineProperty</a><em>(target,key,desc)</em>
					<span>
						基本等同于Object.defineProperty，用来为对象定义属性。
					</span>
				</li>
                <li>
					Reflect.<a href="">preventExtensions</a><em>(target)</em>
					<span>
						对应Object.preventExtensions方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。
					</span>
				</li>
				<li>
					Reflect.<a href="">isExtensible</a><em>(target)</em>
					<span>
						对应Object.isExtensible，返回一个布尔值，表示当前对象是否可扩展。
					</span>
				</li>
                <li>
					Reflect.<a href="">getPrototypeOf</a><em>(obj)</em>
					<span>
						用于读取对象的__proto__属性，对应Object.getPrototypeOf(obj)。
					</span>
				</li>
				<li>
					Reflect.<a href="">setPrototypeOf</a><em>(obj,proto)</em>
					<span>
						用于设置对象的__proto__属性，返回第一个参数对象，对应Object.setPrototypeOf(obj, newProto)。
					</span>
				</li>
			</ul>
        </div>
    </div>
</div>