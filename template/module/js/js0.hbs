<div class="u-col">
    <div class="u-block">
        <h3>语法<span>+</span></h3>
        <div class="u-list" style="display:none;">
            <h4>[<span>-</span>] 变量与常量</h4>
            <ul>
                <li>
                    <a href="">var</a>
                    <span>
                        x1 = 1;<br />
                        var x2 = 2;<br />
                        window.x3 = 3;<br />
                        <a href="http://snandy.iteye.com/blog/720816">3种全局变量的异同</a> <hr>
                        1.变量会提升，在没有声明前调用，会输出undefined <br>
                        2.假设声明a、b、c,且c=a+b，且均为非引用类型，当ab发生变化时，c不会改变，应设为c=fn(return a+b)
                    </span>
                </li>
                <li>
                    <a href="">let</a>
                    <span>
                        let i = 1;<br>
                        1.申明一个块级作用域的变量 <br>
                        2.不能使用let重复定义一个变量 <br>
                        3.只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响，暂时性死区。<br>
                    </span>
                </li>
                <li>
                    <a href="">const</a>
                    <span>
                        const PI = 3.14 <br>
                        1.const来定义常量，在声明时就必须赋值。<br>
                        2.const与let都具有块级作用域。 <br>
                        2.一旦声明，常量的指针就不能改变（仅指针，非值本身）
                    </span>
                </li>
            </ul>
            <h4>[<span>-</span>] 运算符</h4>
            <ul>
                <li>
                    <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Expressions_and_Operators">运算符</a>
                </li>
                <li>
                    <a href="">void</a>
                    <span>
                        void运算符对给定的表达式进行求值，然后返回 undefined <br>
                        在使用立即执行的函数表达式时，可以利用 void 运算符让 JavaScript 引擎把一个function关键字识别成函数表达式而不是函数声明（语句）
                    </span>
                </li>
            </ul>
            <h4>[<span>-</span>] 判断</h4>
            <ul>
                <li>
                    <a href="">if..else..</a>
                    <span>
                        if.. <br>
                        if..else.. <br>
                        if..else if..else..
                    </span>
                </li>
                <li>
                    <a href="">switch</a>
                    <span>
                        switch(expression){ <br>
                            case ex:<br>
                                ..<br>
                            break;<br>
                            default:<br>
                                ..<br>
                        }<br>
                        1.switch中的case为全等判断<br>
                        2.多个case使用同一个执行块应写为case 1: case2: ... <br>
                        3.每个case代码块内部的break不能少，否则会接着执行下一个case
                    </span>
                </li>
            </ul>
            <h4>[<span>-</span>] 循环</h4>
            <ul>
                <li>
                    <a href="">for</a>
                    <span>
                        设置循环变量的部分和循环体内部有各自单独的作用域，变量彼此不影响（使用let时）。
                    </span>
                </li>
                <li>
                    <a href="">for..in</a>
                    <span>
                        循环一个对象所有可枚举的属性
                    </span>
                </li>
                <li>
                    <a href="">for..of</a>
                    <span>
                        在可迭代的对象上创建了一个循环 <br>
                        包括Array, Map, Set, 参数对象（ arguments） 等等
                    </span>
                </li>
                <li>
                    <a href="">do..while</a>(exp)
                    <span>
                        一直重复直到指定的条件求值得到假
                    </span>
                </li>
                <li>
                    <a href="">while</a>(exp)..
                    <span>
                        一个 while 语句只要指定的条件求值为真（true）就会一直执行它的语句块
                    </span>
                </li>
                <li>
                    <a href="">label</a>:
                    <span>
                        使用 break 或者 continue 来指出程序是否该停止循环还是继续循环
                    </span>
                </li>
                <li>
                    <a href="">break</a> [label]
                    <span>
                        跳出(内部/指定)循环 
                    </span>
                </li>
                <li>
                    <a href="">continue</a> [label]
                    <span>
                        跳至(内部/指定)循环 <hr>
                        不带参数的break和continue语句都只针对最内层的循环，如continue语句后面不使用标签，则进入下一轮的内层循环 <br>
                        带参数的break和continue语句，满足条件时，会跳过当前循环，直接进入下一轮外层循环
                    </span>
                </li>
            </ul>
            <h4>[<span>-</span>] 模块</h4>
			<ul>
                <li>
                    <a href="">import $path</a>
                    <span>
                        引入某个模块
                    </span>
                </li>
                <li>
                    <a href="">export default $mod</a>
                    <span>
                        输出某个模块
                    </span>
                </li>
                <li>
                    <a href="">import $mod from $path</a>
                    <span>
                        引入某个模块
                    </span>
                </li>
				<li>
            		<a href="">export {mods,..}</a>
            		<span>
            			导出多个模块 <br>
                        也可以将其导出时更换为别的名称：<br>
                        export {<br>
                            $inner as $outer,<br>
                            .. <br>
                        }
            		</span>
            	</li>
            	<li>
            		<a href="">import {mods,..} from $path</a>
            		<span>
            			导入多个模块 <br>
                        也可以在导入时将其重命名：<br>
                        import {
                            $old as $new,<br>
                            .. <br>
                        } <hr>
                        也可以将其全部导入在一个对象下： <br>
                        import * as $modc from $path <br>
            		</span>
            	</li>
			</ul>
            <h4>[<span>-</span>] 异常</h4>
            <ul>
                <li>
                    <a href="">Error</a>
                    <span>
                        new Error('msg') <br>
                        错误对象属性：
                        <table>
                            <tr>
                                <th>属性</th>
                                <th>描述</th>
                            </tr>
                            <tr>
                                <td>err.message</td>
                                <td>错误提示信息</td>
                            </tr>
                            <tr>
                                <td>err.name</td>
                                <td>错误名称（非标准属性）</td>
                            </tr>
                            <tr>
                                <td>err.stack</td>
                                <td>错误的堆栈（非标准属性）</td>
                            </tr>
                        </table>
                        <br>
                        原生错误类型：
                        <table>
                            <tr>
                                <th>名称</th>
                                <th>描述</th>
                            </tr>
                            <tr>
                                <td>SyntaxError</td>
                                <td>解析代码时发生的语法错误</td>
                            </tr>
                            <tr>
                                <td>ReferenceError</td>
                                <td>引用一个不存在的变量时发生的错误；将一个值分配给无法分配的对象</td>
                            </tr>
                            <tr>
                                <td>RangeError</td>
                                <td>当一个值超出有效范围时发生的错误</td>
                            </tr>
                            <tr>
                                <td>TypeError</td>
                                <td>变量或参数不是预期类型时发生的错误</td>
                            </tr>
                            <tr>
                                <td>URIError</td>
                                <td>URI相关函数的参数不正确时抛出的错误</td>
                            </tr>
                            <tr>
                                <td>EvalError</td>
                                <td>eval函数没有被正确执行</td>
                            </tr>
                            <tr>
                                <td>自定义错误</td>
                                <td><a href="http://javascript.ruanyifeng.com/grammar/error.html">参考资料</a></td>
                            </tr>
                        </table>
                        <br><br>
                        如果在一个函数内部发生了错误，它自身没有捕获，错误就会被抛到外层调用函数，如果外层函数也没有捕获，该错误会一直沿着函数调用链向上抛出，直到被JavaScript引擎捕获，代码终止执行。所以，我们不必在每一个函数内部捕获错误，只需要在合适的地方来个统一捕获，一网打尽。<hr>
                        涉及到异步代码，无法在调用时捕获，原因就是在捕获的当时，回调函数并未执行。<br>
                        类似的，当我们处理一个事件时，在绑定事件的代码处，无法捕获事件处理函数的错误。
                    </span>
                </li>
                <li>
                    <a href="">try..catch</a>
                    <span>
                        try{..} <br>
                        catch(e){..} <br>
                        finally{..}
                    </span>
                </li>
                <li>
                    <a href="">throw</a>
                    <span>
                        抛出一个异常
                    </span>
                </li>
                <li>
                    <a href="">debugger</a>
                    <span>
                        调用任何可用的调试功能，例如设置断点。
                    </span>
                </li>
            </ul>
        </div>
    </div>
    <div class="u-block">
		<h3>函数<span>+</span></h3>
		<div class="u-list" style="display:none;">
			<h4>[<span>-</span>] 构建</h4>
			<ul>
				<li>
					<a href="">function name</a><em>(arg){}</em>
					<span>
						函数声明 <br>
						1.使用函数声明时，会提升优先级（一等公民），不包括函数表达式。 <br>
						2.如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。<br>
						3.函数参数是拷贝值传递：对于基本类型，不会修改原值；对于引用类型，拷贝的是指针，如修改原数据属性会改变原数据，如替换整个目标则不修改原数据，此外始终不改变原指针的指向。<a href="http://javascript.ruanyifeng.com/grammar/function.html">参考资料</a> <br>
						4.函数可以被递归，函数可以调用其本身。 <br>
						5.ES6中块级作用域中声明的函数，在块级作用域之外不可引用
					</span>
				</li>
				<li>
					var handle = <a href="">function [name]</a><em>(arg){}</em>
					<span>
						函数表达式<br>
						1.函数表达式是一个匿名函数 <br>
						2.当定义name时，此时可以用name在函数内部指代函数本身，但在函数体外部无效 <br>
						3.函数表达式，不会被提升。<br>
						4.如果同时采用function命令和赋值语句声明同一个函数，最后总是采用赋值语句的定义。 <a href="http://javascript.ruanyifeng.com/grammar/function.html#toc5">参考资料</a> <br>
					</span>
				</li>
				<li>
					(x) <a href="">=></a> x*x
					<span>
						箭头函数 <br>
						1.不可以当做构造函数，即不能使用new操作符 <br>
						2.不可以使用arguments、super、new.target，均指向外层函数的对应变量 <br>
						3.不可以使用yield命令，因此箭头函数不能用作 Generator 函数 <br>
						4.没有自己的this，函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象，且固定不可变，即使使用call也无法修改，更多的可在构造函数或闭包内使用，则可替代普通函数需要用that指代this。 <br>
						this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。所以call的绑定也是无效，但上层的普通函数的call绑定有效。 <br>
						5.没有prototype属性，也不能使用yield关键字
						<hr>
						例：<br>
						1.当只有一行直接返回变量的处理时，x=>x*x，返回x的平方 <br>
						2.当只有一行且无需返回值时，x=>void dosomething <br>
						3.当有多个参数或多条语句时，需添加括号和花括号，(x,y)=>{dosomething / return xx}
					</span>
				</li>
				<li>
					var handle = <a href="">new Function</a><em>('arg..','fnbody')</em>
					<span>
						Function构造函数构建<br>
						1.此形式构建的是匿名函数 <br>
						2.参数为字符串<br>
						3.只有最后一个参数会被当做函数体，如果只有一个参数，该参数就是函数体。
					</span>
				</li>
				<li>
					<a href="">IIFE</a>
					<span>
						( function(){}() ); <br>
						( function(){} )(); <br>
						[ function(){}() ]; <br>
						<br>
						~ function() {}(); <br>
						! function() {}(); <br>
						+ function() {}(); <br>
						- function() {}(); <br>
						<br>
						delete function() {}(); <br>
						typeof function() {}(); <br>
						void function() {}(); <br>
						new function() {}(); <br>
						new function() {}; <br>
						<br>
						var f = function() {}(); <br>
						<br>
						1, function() {}(); <br>
						1 ^ function() {}(); <br>
						1 > function() {}(); 
					</span>
				</li>
			</ul>
			<h4>[<span>-</span>] 参数</h4>
			<ul>
				<li>
					<a href="">(arg=x)</a>
					<span>
						一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域 <a href="http://es6.ruanyifeng.com/#docs/function#作用域">参考资料</a>
					</span>
				</li>
				<li>
					<a href="">...args</a>
					<span>
						rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。 <br>
						rest 参数之后不能再有其他参数（即只能是最后一个参数）
					</span>
				</li>
				<li>
					<a href="">arguments</a>
					<span>
						函数的实参，一个类数组对象。 <br>
						1.在JavaScript中，函数参数的默认值是undefined <br>
						2.严格模式下为只读对象，不允许修改。 <br>
						3.箭头函数不存在(浏览器)
						<table>
							<tr>
								<th>对象值</th>
								<th>描述</th>
							</tr>
							<tr>
								<td>arguments[0]</td>
								<td>第一个参数名字</td>
							</tr>
							<tr>
								<td>arguments.length</td>
								<td>参数的个数</td>
							</tr>
							<tr>
								<td>arguments.callee</td>
								<td>主体函数本身，拥有这个参数对象的函数 (严格模式禁用)</td>
							</tr>
						</table>
					</span>
				</li>
				<li>
					fn.<a href="">length</a>
					<span>
						返回函数预期传入的参数个数，即函数定义之中的参数个数(定义之时的个数) <br>
						指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。
					</span>
				</li>
			</ul>
			<h4>[<span>-</span>] 内部</h4>
			<ul>
				<li>
					<a href="">var</a>
					<span>
						var为静态作用域 <br>
						即词法作用域，取决于函数声明时所在的作用域，与其运行时所在的作用域无关。 <hr>
						执行上下文栈：变量对象、作用域链、this <br>
						1.变量对象：函数的所有形参、函数声明、变量声明（如果变量名称与声明的形参或函数相同，则变量声明不会干扰已经存在的这类属性）<a href="https://github.com/mqyqingfeng/Blog/issues/5">参考资料</a><br>
						<b>变量对象为进入执行上下文阶段，在执行阶段，可能被重新赋值。</b><br>
						2.作用域链：[VO=>AO压入栈顶,全局作用域链] <br>
						3.闭包：<a href="https://github.com/mqyqingfeng/Blog/issues/9">参考资料</a> <hr>
					</span>
				</li>
				<li>
					<a href="">this</a>
					<span>
						this为动态作用域 <br>
						1.普通函数：根据执行环境不同而不同，可以通过apply,call改变 <br>
						2.箭头函数：声明时上下文中的this，不可通过apply,call改变
						<hr> 
						普通函数：严格模式(undefined)、严格模式(全局对象) <br>
						构造函数：对象的实例 <br>
						对象方法：对象本身 <br>
						call/apply/bind：绑定的对象 <br>
						箭头函数：函数所在的块的this <hr>
						<a href="https://github.com/mqyqingfeng/Blog/issues/7">从ES规范解读this</a> 
					</span>
				</li>
				<li>
					<a href="">return</a> [val]
					<span>
						如果没有return语句，函数执行完毕后也会返回结果，只是结果为undefined. <br>
						<a href="http://es6.ruanyifeng.com/#docs/function#尾调用优化">尾调用优化</a>
					</span>
				</li>
			</ul>
			<h4>[<span>-</span>] 方法</h4>
			<ul>
				<li>
					fn<a href="">.call</a>(obj,arg)
					<span>
						fn.call(作用域，[传递参数]) <br>	
						apply与call均让函数作用于特定作用域,call必须明确传入每一个参数。<br>
						apply()把参数打包成Array再传入；call()把参数按顺序传入 <br>
						对普通函数调用，我们通常把this绑定为null。 <br>
						在非严格模式下，如果参数为空、null和undefined，则默认传入全局对象。
					</span>
				</li>
				<li>
					fn<a href="">.apply</a>(obj,[argArr])
					<span>
						fn.apply(作用域，[传递参数Arr]) 
					</span>
				</li>
				<li>
					fn<a href="">.bind</a>(obj)
					<span>
						返回由指定的this值和初始化参数改造的原函数拷贝
						<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">参考资料</a>
				</span></li>
				<li>
					fn.<a href="">toString()</a>
					<span>
						返回一个表示当前函数源代码的字符串，注释也可以返回
					</span>
				</li>
			</ul>
            <h4>[<span>-</span>] 全局函数</h4>
            <ul>
                <li>
                    <a href="">eval</a>(str)
                    <span>
                        将传入的字符串当做 JavaScript 代码进行执行。<br>
						1.eval没有自己的作用域，都在当前作用域内执行。<br>
                        2.JavaScript规定，如果使用严格模式，eval内部声明的变量，不会影响到外部作用域。 <br>
						3.在严格模式下，eval依然可以读写当前作用域的变量。<br>
                        4.eval“间接调用”时作用域总是全局作用域
                        <a href="http://javascript.ruanyifeng.com/grammar/function.html#toc24">参考资料</a>
                    </span>
                </li>
            </ul>
		</div>
	</div>
    <div class="u-block">
		<h3>面向对象<span>+</span></h3>
		<div class="u-list" style="display:none;">
			<h4>[<span>-</span>] 类与继承</h4>
			<ul>
				<li>
					<a href="">class</a> name
					<span>
						1.类的内部所有定义的方法，都是不可枚举的。 <br>
						2.类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。<br>
						3.类不存在变量提升 <br>
						4.类不能继承常规（非可构造）对象，如要继承常规对象，则改用Object.setPrototypeOf()
					</span>
				</li>
				<li>
					<a href="">class $child extends $parent</a>
					<span>
						1.如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。<br>
						2.在子类的构造函数中，只有调用super之后，才可以使用this关键字
                	</span>
				</li>
				<li>
					class.<a href="">constructor</a>([opt]){}
					<span>
						1.constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法<br>	
						2.一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。
					</span>
				</li>
				<li>
					class.<a href="">super</a>(key)|.fn
					<span>
						1.super作为函数调用时，代表父类的构造函数。 <br>
						2.super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。

						<table>
							<tr>
								<td>环境</td>
								<td>this</td>
								<td>super</td>
							</tr>
							<tr>
								<td>构造函数</td>
								<td>实例对象</td>
								<td>父类构造函数</td>
							</tr>
							<tr>
								<td>普通方法</td>
								<td>实例对象</td>
								<td>父类原型对象</td>
							</tr>
							<tr>
								<td>静态方法</td>
								<td>类</td>
								<td>父类</td>
							</tr>
						</table>
					</span>
				</li>
				<li>
					class.<a href="">fn</a>(){}
					<span>
						原型方法
					</span>
				</li>
                <li>
                	class.<a href="">static fn</a>(){}
                	<span>
                		1.静态方法不会被实例继承，而是直接通过类来调用 <br>
						2.静态方法会被子类继承 <br>
                		3.如果静态方法包含this关键字，这个this指的是类，而不是实例。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes">参考资料</a>
                	</span>
                </li>
				<li>
					class.<a href="">get|set prop</a>(){}
					<span>
						getter/setter
					</span>
				</li>
			</ul>
			<h4>[<span>+</span>] 类修饰器</h4>
			<ul style="display:none;">
				<li>
					<a href="">@decorator</a>(cls)
					<span>
						修饰器是一个对类进行处理的函数
					</span>
				</li>
				<li>
					<a href="">@decorator</a>(cls,prop,desc)
					<span>
						修饰器不仅可以修饰类，还可以修饰类的属性
					</span>
				</li>
			</ul>
			<h4>[<span>+</span>] 原型链</h4>
			<ul style="display:none;">
				<li>
					cst.<a href="">prototype</a>
					<span>
                		返回值：构造函数创建的实例的原型（prototype是函数才会有的属性） <br>
                    	为减少内存消耗，将公共方法写在构造函数的原型上，<a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014344997235247b53be560ab041a7b10360a567422a78000">参考资料</a> <br>
						在改变原型对象时，一般要同时设置constructor属性 <br>
                	</span>
				</li>
				<li>
					pro.<a href="">constructor</a>
					<span>
                    	原型对象的这个属性指向构造函数 <br>
                    	<img src="image/js/prototype.png" alt="" style="background-color:#fff;"> <br>
                        <a href="https://github.com/mqyqingfeng/Blog/issues/2">参考资料</a>
                	</span>
				</li>
				<li>
					obj.<a href="">__proto__</a>
					<span>
						返回值：Object / 构造函数原型对象（仅浏览器环境） <br>
						在编写JavaScript代码时，不要直接用obj.__proto__去改变一个对象的原型，并且，低版本的IE也无法使用__proto__。 
					</span>
				</li>
			</ul>
			<h4>[<span>+</span>] 原型方法</h4>
			<ul style="display:none;">
                <li>
					<a href="">Object.create</a>(obj)
					<span>
						基于一个对象创建新对象，源对象会成为新对象的原型对象，原型对象属性并不能在自身默认可见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create">参考资料</a><br>
						不能直接将b的原型赋值给a，否则当b的原型修改时，a的原型也会被更改 <hr>
						Child.prototype = Object.create(Parent.prototype) <br>	Child.prototype.constructor = Child
					</span>
				</li>
				<li>
					pro.<a href="">isPrototypeOf</a>(obj)
					<span>
						判断当前对象是否为另一个对象的原型 <br>
						Object.prototype处于原型链的最顶端，所以对各种实例都返回true，只有继承null的对象除外。
					</span>
				</li>
				<li>
					<a href="">Object.getPrototypeOf</a>(obj)
					<span>
						获取对象的原型对象
					</span>
				</li>
				<li>
					<a href="">Object.setPrototypeOf</a><em>(obj,proto)</em>
					<span>
						为现有对象设置原型，返回新对象。
					</span>
				</li>
			</ul>
        </div>
    </div>
    <div class="u-block">
        <h3>数据类型<span>+</span></h3>
        <div class="u-list">
            <h4>[<span>+</span>] 数据类型</h4>
            <ul style="display:none">
                <li>
                    <a href="">Boolean</a>
                    <span>
                        布尔:原始类型
                    </span>
                </li>
                <li>
                    <a href="">Number</a>
                    <span>
                        数值：原始类型 <br>
                        根据 ECMAScript 标准，JavaScript 中只有一种数字类型：基于 IEEE 754 标准的双精度 64 位二进制格式的值（-(263 -1) 到 263 -1） <br>
                        数字类型只有一个整数: 0
                    </span>
                </li>
                <li>
                    <a href="">String</a>
                    <span>
                        字符串：原始类型 <br>
                        JavaScript 字符串是不可更改的
                    </span>
                </li>
                <li>
                    <a href="">Symbol</a>
                    <span>
                        符号：原始类型 <br>
                        符号类型是唯一的并且是不可修改的,可以用来作为Object的key的值
                    </span>
                </li>
                <li>
                    <a href="">Undefined</a>
                    <span>
                        未定义：原始类型 <br>
                        一个没有被赋值的变量会有个默认值 undefined
                    </span>
                </li>
                <li>
                    <a href="">Null</a>
                    <span>
                        空：原始类型 <br>
                        Null 类型只有一个值： null <br>
                        <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management">内存优化</a>
                    </span>
                </li>
                <li>
                    <a href="">Object</a>
                    <span>
                        对象：引用类型（包括数组、函数、标准对象等）
                    </span>
                </li>
            </ul>
            <h4>[<span>-</span>] 类型检测</h4>
            <ul>
                <li>
                    <a href="">typeof</a> val
                    <span>
                        返回的是字符串。 <br>
                        可通过Object.prototype.toString.call(o)测试
                        <table>
                            <tr>
                                <th>类型</th>
                                <th>结果</th>
                            </tr>
                            <tr>
                                <td>true/false</td>
                                <td>boolean</td>
                            </tr>
                            <tr>
                                <td>数值/NaN</td>
                                <td>boolean</td>
                            </tr>
                            <tr>
                                <td>Symbol</td>
                                <td>symbol</td>
                            </tr>
                            <tr>
                                <td>字符串/JSON</td>
                                <td>string</td>
                            </tr>
                            <tr>
                                <td>fn</td>
                                <td>function</td>
                            </tr>
                            <tr>
                                <td>obj/数组/null</td>
                                <td>object</td>
                            </tr>
                            <tr>
                                <td>undefined/不存在的属性或方法</td>
                                <td>undefined</td>
                            </tr>
                        </table>
                        <br><hr>
                        1.判断null请使用myVar === null <br>
                        2.不存在的变量与未声明的变量typeof检测均为undefined，但两者其实不同，故建议总是初始化。 <br>
                        3.Null 类型是一个只有一个值的数据类型，即特殊的值 null。它表示一个空对象引用(指针)，而 typeof 操作符检测 null 会返回 object。如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为 null。这样，当检查 null 值就知道是否已经变量是否已经分配了对象引用了。<br>
                        4.undefined 是派生自 null 的，因此 ECMA-262 规定对它们的相等性测试返回 true。alert(undefined == null);但typeof数据类型不等。
                    </span>
                </li>
                <li>
                    obj <a href="">instanceof</a> cst
                    <span>instanceof运算符返回一个布尔值，表示某个对象是否为指定的构造函数的实例。
                        <table>
                            <tr>
                                <th>测试目标</th>
                                <th>测试结果</th>
                            </tr>
                            <tr>
                                <td>数组</td>
                                <td>arr instanceof Array</td>
                            </tr>
                            <tr>
                                <td>函数/构造函数</td>
                                <td>fn instanceof Function</td>
                            </tr>
                            <tr>
                                <td>构造函数实例</td>
                                <td>child instanceof parent</td>
                            </tr>
                            <tr>
                                <td>泛对象</td>
                                <td>obj instanceof Object</td>
                            </tr>
                            <tr>
                                <td>日期</td>
                                <td>value instanceof Date</td>
                            </tr>
                            <tr>
                                <td>正则表达式</td>
                                <td>value instanceof RegExp</td>
                            </tr>
                            <tr>
                                <td>数学</td>
                                <td>value instanceof Math</td>
                            </tr>
                        </table>
                    </span>
                </li>
            </ul>
            <h4>[<span>+</span>] 类型转换</h4>
            <ul style="display:none;">
                <li>
                    <a href="">Boolean</a>(val)
                    <span>
                        省略该参数 <br>
                        其值为 0、-0、null、false、NaN、undefined、或者空字符串（""）<br>
                        参数是DOM对象document.all <br>
                        以上均生成值为false的Boolean对象
                    </span></li>
                <li>
                    <a href="">Number</a>(val)
                    <span>
                        <table>
                            <tr>
                                <th>value</th>
                                <th>返回值</th>
                            </tr>
                            <tr>
                                <td>number/包含单个数值的数组</td>
                                <td>number</td>
                            </tr>
                            <tr>
                                <td>boolean</td>
                                <td>1 / 0</td>
                            </tr>
                            <tr>
                                <td>null/空字符串/空数组</td>
                                <td>0</td>
                            </tr>
                            <tr>
                                <td>undefined/string/object</td>
                                <td>NaN</td>
                            </tr>
                        </table>
                    </span></li>
                <li>
                    <a href="">String</a>(val)
                    <span>
                        <table>
                            <tr>
                                <th>value</th>
                                <th>返回值</th>
                            </tr>
                            <tr>
                                <td>数值</td>
                                <td>转为相应的字符串</td>
                            </tr>
                            <tr>
                                <td>字符串</td>
                                <td>转换后还是原来的值</td>
                            </tr>
                            <tr>
                                <td>布尔值</td>
                                <td>true转为"true"，false转为"false"</td>
                            </tr>
                            <tr>
                                <td>undefined</td>
                                <td>转为"undefined"</td>
                            </tr>
                            <tr>
                                <td>null</td>
                                <td>转为"null"</td>
                            </tr>
                            <tr>
                                <td>数组</td>
                                <td>返回该数组的字符串形式  "1,2,3"</td>
                            </tr>
                            <tr>
                                <td>对象</td>
                                <td>返回一个类型字符串 "[object Object]" <br>可通过toString方法来设置修改</td>
                            </tr>
                        </table>
                    </span>
                </li>
            </ul>
        </div>
    </div>
    <div class="u-block">
		<h3>可迭代对象<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>-</span>] Iterable</h4>
			<ul>
				<li>
					<a href="">[...iterable]</a>
					<span>
						只要具有 Iterator 接口的对象，都可以使用扩展运算符<br>
						[...str] <br>
						[...arr|TypedArray] <br>
						[...set|map] <br>
						[...arguments] <br>
						[...nodeList] 
					</span>
				</li>
				<li>
					<a href="">for(.. of iterable)</a>
					<span>
						for(let key of iterable){} <br>
						任何部署了Interator接口的数据都可以用for..of来遍历 <br>
						String、Array、TypedArray、Map、Set、函数arguments对象、NodeList对象都内置Interator接口，因为它们的原型对象都有一个 Symbol.iterator 方法。 <hr>
						数组使用for .. of 直接取值更快捷
					</span>
				</li>
				<li>
					<a href="">for await(.. of iterable)</a>
					<span>
						遍历异步的 Iterator 接口
					</span>
				</li>
			</ul>
			<h4>[<span>-</span>] Iterator</h4>
			<ul>
				<li>
					o.<a href="">[Symbol.iterator]</a>
					<span>
						一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的” <br>
						Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。<br>
						执行这个函数，就会返回一个遍历器。 <br>
						<a href="http://es6.ruanyifeng.com/#docs/iterator">给对象自定义一个遍历器</a> <hr>
						由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口。
					</span>
				</li>
				<li>
					ite.<a href="">next([val])</a>
					<span>
						每次调用next方法，都会返回一个代表当前成员的信息对象，具有value和done两个属性。
					</span>
				</li>
				<li>
					ite.<a href="">return([val])</a>
					<span>
						如果一个对象在完成遍历前，需要清理或释放资源，就可以部署return方法 <br>
					</span>
				</li>
				<li>
					ite.<a href="">throw([val])</a>
					<span>
						<a href="http://es6.ruanyifeng.com/#docs/generator#next、throw、return-的共同点">next、throw、return的共同点</a>
					</span>
				</li>
			</ul>
			<h4>[<span>-</span>] Generator</h4>
			<ul>
				<li>
					<a href="">function*</a> {ite}
					<span>
						执行 Generator 函数会返回一个遍历器对象 <hr>
						这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的prototype对象上的方法 <br>
						<a href="http://es6.ruanyifeng.com/#docs/generator#Generator-函数的this">Generator的this与new</a> <br>
						var g = Generator.call(Generator.prototype) <br>
						此时Generator函数中的this指向实例g <br>
						var F() = {return Generator.call(Generator.prototype)} <br>
						则可通过 var f = new F() 来生成实例 
					</span>
				</li>
				<li>
					<a href="">yield[*]</a>
					<span>
						暂停标志，遍历器每执行一次next则执行当前yield。<hr>
						yield表达式本身没有返回值，或者说总是返回undefined。<br> 
						next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值，作为当下一个yield依赖上一个yield时使用。 <hr>
						yield表达式后面执行一个函数，函数的返回值，相当于生成器运行了该步骤并返回给遍历器对象value的值。
						Generator 函数也可以不用yield表达式，这时就变成了一个单纯的暂缓执行函数。<hr>
						在Generator函数内部，调用另一个 Generator 函数，需要使用yield* Generator() <br>
						会一次执行完被代理对象的全部步骤
					</span>
				</li>
				<li>
					<a href="">return</a>
					<span>
						结束标志
					</span>
				</li>
			</ul>
			<h4>[<span>-</span>] Async Function</h4>
            <ul>
            	<li>
            		<a href="">async function</a> {promise}
            		<span>
            			async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。
            		</span>
            	</li>
            	<li>
            		<a href="">await</a> promise
            		<span>
            			await表示紧跟在后面的表达式需要等待结果 <br>
						async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）
            		</span>
            	</li>
            	<li>
            		<a href="">return</a>
            		<span>
            			async函数内部return语句返回的值，会成为then方法回调函数的参数
            		</span>
            	</li>
            </ul>
			<h4>[<span>-</span>] Async Iterator</h4>
			<ul>
				<li>
					o.<a href="">[Symbol.asyncIterator]</a>
					<span>
						asyncIterator是一个异步遍历器
					</span>
				</li>
				<li>
					aite.<a href="">next()</a> {promise}
					<span>
						调用next方法以后，返回一个 Promise 对象。<br>
						因此，可以使用then方法指定，这个 Promise 对象的状态变为resolve以后的回调函数。<br>
						回调函数的参数，则是一个具有value和done两个属性的对象，这个跟同步遍历器是一样的。
					</span>
				</li>
			</ul>
			<h4>[<span>-</span>] Async Generator</h4>
			<ul>
				<li>
					async <a href="">function*</a> {aite}
					<span>
						返回一个异步遍历器对象
					</span>
				</li>
				<li>
					<a href="">yield*</a>
					<span>
						yield*语句也可以跟一个异步遍历器
					</span>
				</li>
			</ul>
		</div>
	</div>
    <div class="u-block">
        <h3>扩展<span>-</span></h3>
        <div class="u-list">
            <h4>[<span>-</span>] 扩展</h4>
            <ul>
                <li>
                    <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly">WebAssembly</a>
                </li>
            </ul>
        </div>
    </div>
	<div class="u-block">
		<h3>参考资料<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>+</span>] 文档</h4>
			<ul style="display: none;">
				<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference">JS参考文档</a></li>
				<li><a href="http://kangax.github.io/compat-table/es6/">ES6支持程度</a></li>
				<li><a href="http://yanhaijing.com/es5/">ECMAScript5规范</a></li>
			</ul>
			<h4>[<span>+</span>] 教程</h4>
			<ul style="display: none;">
				<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide">JS指南</a></li>
				<li><a href="http://javascript.ruanyifeng.com">ES5教程</a></li>
				<li><a href="http://es6.ruanyifeng.com">ES6教程</a></li>
			</ul>
			<h4>[<span>+</span>] 动态</h4>
			<ul style="display: none;">
				<li><a href="https://www.awesomes.cn/">前端库大全</a></li>
				<li><a href="https://juejin.im/welcome/frontend">掘金社区</a></li>
			</ul>
		</div>
	</div>
</div>