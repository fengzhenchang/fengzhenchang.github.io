<div class="u-col">
    <div class="u-block">
        <h3>语法<span>+</span></h3>
        <div class="u-list" style="display:none;">
            <h4>[<span>+</span>] 变量与常量</h4>
            <ul style="display:none;">
                <li>
                    <a href="">变量</a>
                    <span>
                        1.变量没有类型，类型属于对象，变量只是一个对象的引用（指针）<br>
                        2.不可变类型：数值、字符串、元组；其余为可变类型 <br>
                        3.Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。<br>
                        4.同时为多个变量赋值：a = b = c = 1 <br>
                        5.为多个对象指定多个变量：a, b, c = 1, 2, "test" <br>
                        6.if/for/while等不会引入新的作用域，无块作用域
                    </span>
                </li>
                <li>
                    <a href="">常量</a>
                    <span>
                        常量仍然可以修改，全部大写定义。
                    </span>
                </li>
                <li>
                    <a href="">del</a> $var,..
                    <span>
                        删除单个或多个对象的引用
                    </span>
                </li>
            </ul>
            <h4>[<span>+</span>] 运算符</h4>
            <ul style="display:none">
                <li>
                    <a href="">算数运算符</a>
                    <span>
                        <table>
                            <caption>算数运算符</caption>
                            <tr>
                                <th>运算符</th>
                                <th>描述</th>
                                <th>更多</th>
                            </tr>
                            <tr>
                                <td>+</td>
                                <td>相加</td>
                                <td>数据串联</td>
                            </tr>
                            <tr>
                                <td>-</td>
                                <td>相减，负数</td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>*</td>
                                <td>相乘</td>
                                <td>重复若干次的数据</td>
                            </tr>
                            <tr>
                                <td>**</td>
                                <td>乘方</td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>/</td>
                                <td>精确除法</td>
                                <td>总是返回一个浮点数，例如6/3=2.0</td>
                            </tr>
                            <tr>
                                <td>//</td>
                                <td>地板除</td>
                                <td>只取整数部分，返回向下取整后的结果。// 得到的并不一定是整数类型的数，它与分母分子的数据类型有关系，如果分子分母为浮点数，求得也为浮点数。</td>
                            </tr>
                            <tr>
                                <td>%</td>
                                <td>取余数</td>
                                <td></td>
                            </tr>
                        </table>
                        不同类型的数混合运算时会将整数转换为浮点数
                    </span>
                </li>
                <li>
                    <a href="">比较运算符</a>
                    <span>
                        <table>
                            <caption>比较运算符</caption>
                            <tr>
                                <th>运算符</th>
                                <th>描述</th>
                                <th>更多</th>
                            </tr>
                            <tr>
                                <td>==</td>
                                <td>等于</td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>!=</td>
                                <td>不等于</td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>&gt;</td>
                                <td>大于</td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>&lt;</td>
                                <td>小于</td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>&gt;=</td>
                                <td>大于等于</td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>&lt;=</td>
                                <td>小于等于</td>
                                <td></td>
                            </tr>
                        </table>
                    </span>
                </li>
                <li>
                    <a href="">赋值运算符</a>
                    <span>
                        <table>
                            <caption>赋值运算符</caption>
                            <tr>
                                <th>运算符</th>
                                <th>描述</th>
                                <th>更多</th>
                            </tr>
                            <tr>
                                <td>=</td>
                                <td>简单的赋值运算符</td>
                                <td>c = a + b 将 a + b 的运算结果赋值为 c</td>
                            </tr>
                            <tr>
                                <td>+=</td>
                                <td>加法赋值运算符</td>
                                <td>c += a 等效于 c = c + a</td>
                            </tr>
                            <tr>
                                <td>-=</td>
                                <td>减法赋值运算符</td>
                                <td>c -= a 等效于 c = c - a</td>
                            </tr>
                            <tr>
                                <td>*=</td>
                                <td>乘法赋值运算符</td>
                                <td>c *= a 等效于 c = c * a</td>
                            </tr>
                            <tr>
                                <td>/=</td>
                                <td>除法赋值运算符</td>
                                <td>c /= a 等效于 c = c / a</td>
                            </tr>
                            <tr>
                                <td>%=</td>
                                <td>取模赋值运算符</td>
                                <td>c %= a 等效于 c = c % a</td>
                            </tr>
                            <tr>
                                <td>**=</td>
                                <td>幂赋值运算符</td>
                                <td>c **= a 等效于 c = c ** a</td>
                            </tr>
                            <tr>
                                <td>//=</td>
                                <td>取整除赋值运算符</td>
                                <td>c //= a 等效于 c = c // a</td>
                            </tr>
                        </table>
                    </span>
                </li>
                <li>
                    <a href="">位运算符</a>
                    <span>
                        <table>
                            <caption>位运算符</caption>
                            <tr>
                                <th>运算符</th>
                                <th>描述</th>
                                <th>更多</th>
                            </tr>
                            <tr>
                                <td>&</td>
                                <td>按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0</td>
                                <td>(a & b) 输出结果 12 ，二进制解释： 0000 1100</td>
                            </tr>
                            <tr>
                                <td>|</td>
                                <td>按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。</td>
                                <td>(a | b) 输出结果 61 ，二进制解释： 0011 1101</td>
                            </tr>
                            <tr>
                                <td>^</td>
                                <td>按位异或运算符：当两对应的二进位相异时，结果为1</td>
                                <td>(a ^ b) 输出结果 49 ，二进制解释： 0011 0001</td>
                            </tr>
                            <tr>
                                <td>~</td>
                                <td>按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1</td>
                                <td>(~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。</td>
                            </tr>
                            <tr>
                                <td><<</td>
                                <td>左移动运算符：运算数的各二进位全部左移若干位，由"<<"右边的数指定移动的位数，高位丢弃，低位补0。</td>
                                <td>a << 2 输出结果 240 ，二进制解释： 1111 0000</td>
                            </tr>
                            <tr>
                                <td>>></td>
                                <td>右移动运算符：把">>"左边的运算数的各二进位全部右移若干位，">>"右边的数指定移动的位数</td>
                                <td>a >> 2 输出结果 15 ，二进制解释： 0000 1111</td>
                            </tr>
                        </table>
                    </span>
                </li>
                <li>
                    <a href="">逻辑运算符</a>
                    <span>
                        <table>
                            <caption>逻辑运算符</caption>
                            <tr>
                                <th>运算符</th>
                                <th>描述</th>
                                <th>更多</th>
                            </tr>
                            <tr>
                                <td>and</td>
                                <td>x and y。布尔"与"。如果 x 为 False，返回 False，否则它返回 y 的计算值。</td>
                                <td>(a and b) 返回 20。</td>
                            </tr>
                            <tr>
                                <td>or</td>
                                <td>x or y。布尔"或"。如果 x 是 True，它返回 True，否则它返回 y 的计算值。</td>
                                <td>(a or b) 返回 10。</td>
                            </tr>
                            <tr>
                                <td>not</td>
                                <td>not x。布尔"非"。如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td>
                                <td>not(a and b) 返回 False</td>
                            </tr>
                        </table>
                    </span>
                </li>
                <li>
                    <a href="">成员运算符</a>
                    <span>
                        <table>
                            <caption>成员运算符</caption>
                            <tr>
                                <th>运算符</th>
                                <th>描述</th>
                                <th>更多</th>
                            </tr>
                            <tr>
                                <td>in</td>
                                <td>如果在指定的序列中找到值返回 True，否则返回 False。</td>
                                <td>x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td>
                            </tr>
                            <tr>
                                <td>not in</td>
                                <td>如果在指定的序列中没有找到值返回 True，否则返回 False。</td>
                                <td>x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td>
                            </tr>
                        </table>
                    </span>
                </li>
                <li>
                    <a href="">身份运算符</a>
                    <span>
                        <table>
                            <caption>身份运算符</caption>
                            <tr>
                                <th>运算符</th>
                                <th>描述</th>
                                <th>更多</th>
                            </tr>
                            <tr>
                                <td>is</td>
                                <td>is是判断两个标识符是不是引用自一个对象</td>
                                <td>x is y, 如果 id(x) 等于 id(y) , is 返回结果True</td>
                            </tr>
                            <tr>
                                <td>is not</td>
                                <td>is not是判断两个标识符是不是引用自不同对象</td>
                                <td>x is not y, 如果 id(x) 不等于 id(y). is not 返回结果True</td>
                            </tr>
                        </table>
                        is 与 == 区别：is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。
                    </span>
                </li>
                <li>
                    <a href="">运算符优先级</a>
                    <span>
                        <table>
                            <tr>
                                <th>运算符</th>
                                <th>描述</th>
                            </tr>
                            <tr>
                                <td>**</td>
                                <td>指数 (最高优先级)</td>
                            </tr>
                            <tr>
                                <td>~ + -</td>
                                <td>按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)</td>
                            </tr>
                            <tr>
                                <td>* / % //</td>
                                <td>乘，除，取模和取整除</td>
                            </tr>
                            <tr>
                                <td>+ -</td>
                                <td>加法减法</td>
                            </tr>
                            <tr>
                                <td>>> <<</td>
                                <td>右移，左移运算符</td>
                            </tr>
                            <tr>
                                <td>&</td>
                                <td>位 'AND'</td>
                            </tr>
                            <tr>
                                <td>^ |</td>
                                <td>位运算符</td>
                            </tr>
                            <tr>
                                <td><= < > >=</td>
                                <td>比较运算符</td>
                            </tr>
                            <tr>
                                <td><> == !=</td>
                                <td>等于运算符</td>
                            </tr>
                            <tr>
                                <td>= %= /= //= -= += *= **=</td>
                                <td>赋值运算符</td>
                            </tr>
                            <tr>
                                <td>is , is not</td>
                                <td>身份运算符</td>
                            </tr>
                            <tr>
                                <td>in , not in</td>
                                <td>成员运算符</td>
                            </tr>
                            <tr>
                                <td>not , or and</td>
                                <td>逻辑运算符</td>
                            </tr>
                        </table>
                        算术>比较>赋值>逻辑
                    </span>
                </li>
            </ul>
            <h4>[<span>+</span>] 判断</h4>
            <ul style="display:none">
                <li>
                    <a href="">if ..:</a>
                    <span>
                        条件语句
                    </span>
                </li>
                <li>
                    <a href="">if .. else ..</a>
                    <span>
                        无括号与花括号，用冒号与缩进代替
                    </span>
                </li>
                <li>
                    <a href="">if .. elif ..</a>
                    <span>
                        在Python中没有switch – case语句
                    </span>
                </li>
                <li>
                    <a href="">pass</a>
                    <span>指示一个没有内容的语句块</span>
                </li>
            </ul>
            <h4>[<span>+</span>] 循环</h4>
            <ul style="display:none">
                 <li>
                    <a href="">while..:</a>
                    <span>条件循环</span>
                </li>
                <li>
                    <a href="">while .. else</a>
                    <span>退出无限循环，循环被break终止时else不执行</span>
                </li>
                <li>
                    <a href="">for ... else</a>
                    <span>
                        不满足循环时，循环被break终止时else不执行
                    </span>
                </li>
                <li>
                    <a href="">break</a>
                    <span>跳出循环</span>
                </li>
                <li>
                    <a href="">continue</a>
                    <span>跳过当前，继续下一轮循环</span>
                </li>
            </ul>
            <h4>[<span>-</span>] 模块</h4>
            <ul>
                <li>
                    <a href="">import</a> module,..
                    <span>
                        引入一个模块(内置/自定义) <br>
                        对应的方法需要使用 module.name来使用 <br>
                        一个文件就是一个模块
                    </span>
                </li>
                <li>
                    <a href="">form module import</a> name,..
                    <span>
                        从模块中导入一个指定的部分到当前命名空间<br>
                        form module import * <br>
                        引入全部变量与函数，但不包括以下划线开头部分 <br>
                        此时将可以直接使用模块内部的名称
                    </span>
                </li>
                <li>
                    <a href="">__name__</a>
                    <span>
                        当模块为独立运行时，值为__main__
                    </span>
                </li>
                <li>
                    <a href="">dir</a>([module])
                    <span>
                        返回这一指定模块内定义的所有名称，会包括函数内所定义的函数、类与变量。以字符串列表形式返回。 <br>
                        参数为空时，返回当前模块的相关列表。
                    </span>
                </li>
                <li>
                    <a href="">sys.path.append</a>(mypath)
                    <span>
                        添加自己的搜索目录 <br>
                        import sys <br>
                        sys.path.append('/mypath')
                    </span>
                </li>
            </ul>
            <h4>[<span>-</span>] 包</h4>
            <ul>
                <li>
                    <a href="">import</a> pkg.module
                    <span>
                        引入某个包中的某个模块 <hr>
                        一个目录就是一个包，必须放置__init__.py文件 <br>
                        __init__.py本身就是一个模块，而它的模块名就是文件夹名 
                    </span>
                </li>
                <li>
                    <a href="">form pkg import</a> module,..
                    <span>
                        引入某个包中的某些模块 <br>
                        <a href="https://www.jianshu.com/p/5cc20b88bcf4">参考资料</a> <br>
                        独立运行时：python -m pkg.module
                    </span>
                </li>
                <li>
                    <a href="">__all__</a>
                    <span>
                        __all__ = ["modname1", "modname2"] <br>
                        如果包定义文件 __init__.py 存在一个叫做 __all__ 的列表变量，那么在使用 from package import * 的时候就把这个列表中的所有名字作为包内容导入
                    </span>
                </li>
            </ul>
            <h4>[<span>-</span>] 异常</h4>
            <ul>
                <li>
                    <a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy">Exception hierarchy</a>
                </li>
                <li>
                    <a href="">try</a>:
                    <span>
                        捕获try语句中的错误
                    </span>
                </li>
                <li>
                    <a href="">except</a> Exception as e:
                    <span>
                        捕获错误，可多个except并列捕获不同类型的错误
                    </span>
                </li>
                <li>
                    <a href="">else</a>:
                    <span>
                        如果没有错误执行的语句块
                    </span>
                </li>
                <li>
                    <a href="">finally</a>:
                    <span>
                        无论如何都会执行的语句块
                    </span>
                </li>
                <li>
                    <a href="">raise</a> [errcls()]
                    <span>
                        自定义错误类，可使用raise抛出 <br>
                        raise语句如果不带参数，就会把当前错误原样抛出 <br>
                        所有的错误类型都继承自BaseException，在使用except时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”。
                    </span>
                </li>
                <li>
                    <a href="">logging.exception(e)</a>
                    <span>
                        import logging <br> 
                        正常打印错误信息继续执行       
                    </span>
                </li>
                <li>
                    <a href="">assert</a> True,str
                    <span>
                        assert 表达式True，否则抛出AssertionError，显示str提示语 <br>
                        启动Python解释器时可以用-O参数来关闭assert，即当作pass
                    </span>
                </li>
            </ul>
            <h4>[<span>+</span>] 其它</h4>
            <ul style="display:none">
                <li>
                    <a href="">注释</a>
                    <span>
                        # 单行注释 <br>
                        """ 多行注释 """
                    </span>
                </li>
                <li>
                    <a href="">r</a>"str"
                    <span>
                        原始字符串，即通过在字符串前加r或R。 <br>
                        如 r"this is a line with \n" 则\n会显示，并不是换行。
                        <table>
                            <thead>
                                <tr>
                                    <th>转义字符</th>
                                    <th>描述</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>\(在行尾时)</td>
                                    <td>续行符</td>
                                </tr>
                                <tr>
                                    <td>\\</td>
                                    <td>反斜杠符号</td>
                                </tr>
                                <tr>
                                    <td>\'</td>
                                    <td>单引号</td>
                                </tr>
                                <tr>
                                    <td>\"</td>
                                    <td>双引号</td>
                                </tr>
                                <tr>
                                    <td>\a</td>
                                    <td>响铃</td>
                                </tr>
                                <tr>
                                    <td>\b</td>
                                    <td>退格(Backspace)</td>
                                </tr>
                                <tr>
                                    <td>\e</td>
                                    <td>转义</td>
                                </tr>
                                <tr>
                                    <td>\000</td>
                                    <td>空</td>
                                </tr>
                                <tr>
                                    <td>\n</td>
                                    <td>换行</td>
                                </tr>
                                <tr>
                                    <td>\v</td>
                                    <td>纵向制表符</td>
                                </tr>
                                <tr>
                                    <td>\t</td>
                                    <td>横向制表符</td>
                                </tr>
                                <tr>
                                    <td>\r</td>
                                    <td>回车</td>
                                </tr>
                                <tr>
                                    <td>\f</td>
                                    <td>换页</td>
                                </tr>
                                <tr>
                                    <td>\oyy</td>
                                    <td>八进制数，yy代表的字符，例如：\o12代表换行</td>
                                </tr>
                                <tr>
                                    <td>\xyy</td>
                                    <td>十六进制数，yy代表的字符，例如：\x0a代表换行</td>
                                </tr>
                                <tr>
                                    <td>\other</td>
                                    <td>其它的字符以普通格式输出</td>
                                </tr>
                            </tbody>
                        </table>
                    </span>
                </li>
            </ul>
        </div>
    </div>
    <div class="u-block">
        <h3>函数<span>+</span></h3>
        <div class="u-list" style="display:none;">
            <h4>[<span>-</span>] 定义与参数</h4>
            <ul>
                <li>
                    <a href="">def</a> fn(arg,*tup|**dic):
                    <span>
                        默认参数：<br>
                        1.定义时通过arg=val赋值默认参数值<br>
                        2.默认参数必须指向不变对象 <hr>
                        参数关键词：<br>
                        1.使用关键词参数时，允许与声明时的顺序不一致 fn(arg2=val2,arg1=val1)<br>
                        2.如果单独出现星号 * 后的参数必须用关键字传入。 <hr>
                        参数传递结果： <br>
                        1.参数传入不可变类型时，传递的只是变量的值，没有影响变量本身，在函数内部修改变量，只是修改另一个复制的对象，不会影响原变量本身。 <br>
                        2.参数传入可变类型时，为引用传递，会将变量的引用传递过去，在函数内部修改后，外部的变量也会受到影响。 <hr>
                        参数解构： <br>
                        1.加了*星号的参数会以元组的形式导入，存放所有未命名的变量参数<br>
                        如果在函数调用时没有指定参数，它就是一个空元组。我们也可以不向函数传递未命名的变量。 <br>
                        2.加了**两个星号的参数会以字典的形式导入 <a href="http://www.runoob.com/python3/python3-function.html">参考资料</a> <br>
                        3.传入一个*seq/**dict时，相当于解构seq/dict传入，注意此解构的内部变量是对kw的一份拷贝，不会影响到传入的原kw。
                    </span>
                </li>
                <li>
                    <a href="">lambda</a> arg : expression
                    <span>
                        1.将lambda表达式赋值给一个变量，成为一个匿名函数 <br>
                        2.无需return，默认表达式的值就是return的值 <br>
                        3.lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数
                    </span>
                </li>
                <li>
                    <a href="">return</a>
                    <span>
                        1.退出函数并返回一个表达式/值，默认返回None <br>
                        2.所谓可以返回多个值，但实际上是以一个元组返回，同时赋值给多个变量 <br>
                        在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple <br>
                    </span>
                </li>
                <li>
                    newfn = <a href="">functools.partial</a>(oldfn,key=val)
                    <span>
                        偏函数 <br>
                        import functools <br>
                        newfn = functools.partial(oldfn,key=val) <br>
                        <a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143184474383175eeea92a8b0439fab7b392a8a32f8fa000">参考资料</a>
                    </span>
                </li>
            </ul>
            <h4>[<span>-</span>] 作用域</h4>
            <ul>
                <li>
                    <a href="">global</a> var
                    <span>
                        全局作用域声明 <br>
                        在内部作用域中需要修改外部作用域变量时
                    </span>
                </li>
                <li>
                    <a href="">nonlocal</a> var
                    <span>
                        外层作用域变量声明 <br>
                        在内部作用域中需要修改外层作用域（非全局）变量时
                    </span>
                </li>
            </ul>
            <h4>[<span>-</span>] 装饰器</h4>
            <ul>
                <li>
                    <a href="">@decfn</a>
                    <span>
                        函数装饰器 <br>
                        from functools import wraps<br>
                        def decname(fn):<br>
                            @wraps(fn)<br>
                            def wrap(*args,**kwargs):<br>
                                return fn(*args,**kwargs)<br>
                            return wrap
                    </span>
                </li>
                <li>
                    <a href="">@clsfn</a>
                    <span>
                        类装饰器 <br>
                        使用类装饰器主要依靠类的__call__方法，当使用 @ 形式将装饰器附加到函数上时，就会调用此方法。 <br>
                        一个函数还可以同时定义多个装饰器，它的执行顺序是从里到外，最先调用最里层的装饰器，最后调用最外层的装饰器
                    </span>
                </li>
                <li>
                    <a href="">__name__</a>
                    <span>
                        返回函数的名字。在类装饰器中无法正常获取
                    </span>
                </li>
                <li>
                    <a href="">@unique</a>
                    <span>
                        @unique装饰器可以帮助我们检查保证没有重复值
                    </span>
                </li>
            </ul>
            <h4>[<span>-</span>] 生成器与迭代器</h4>
            <ul>
                <li>
                    l = <a href="">[v_exp for v in ite if v ..]</a>
                    <span>
                        列表生成式： <br>
                        [x * x for x in range(1, 11)] <br>
                        [x for x in range(1, 11) if x % 2 == 0] <br>
                        返回：一个列表list
                    </span>
                </li>
                <li>
                    g = <a href="">(v_exp for v in ite if v ..)</a>
                    <span>
                        将列表生成式的中括号改为括号则为生成器，也是一个可迭代类型 <br>
                        返回：一个generator
                    </span>
                </li>
                <li>
                    <a href="">yeild</a> val
                    <span>
                        如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator，返回的也是一个generator对象。 <br>
                        generator和函数的执行流程不一样。<br>
                        函数是顺序执行，遇到return语句或者最后一行函数语句就返回。<br>
                        而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。
                    </span>
                </li>
                <li>
                    <a href="">next</a>(Iterator)
                    <span>
                        每调用一次，获得迭代器的下一个返回值 <br>
                        直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误 <br>
                        基本上永远不会调用next()，而是通过for循环来迭代它，并且不需要关心StopIteration的错误<br> 
                        for n in g
                    </span>
                </li>
            </ul>
        </div>
    </div>
    <div class="u-block">
        <h3>面向对象<span>+</span></h3>
        <div class="u-list" style="display:none">
            <h4>[<span>-</span>] 类</h4>
            <ul>
                <li>
                    <a href="">class</a> Name(object)
                    <span>
                        1.默认继承object <br>
                        2.所有方法的第一个参数总是self，指向实例本身;self.__class__指向类本身 <br>
                        3.实例属性找不到时会查找类属性，但实例属性取值时优先类属性
                    </span>
                </li>
                <li>
                    <a href="">__init__</a>(self,arg)
                    <span>
                        实例初始化方法
                    </span>
                </li>
                <li>
                    <a href="">__.</a>prop|fn
                    <span>
                        1.__开头的属性为私有属性/方法，默认外部无法访问，但可以通过_ClassName__prop访问(不保证)。<br>
                        2.但__xx__不是私有，只是特殊。<br>
                        3.如果对私有变量进行修改，实际上是额外新增了一个属性。<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014318650247930b1b21d7d3c64fe38c4b5a80d4469ad7000">参考资料</a> <br>
                        4.对对象新增的属性对其他对象不生效
                    </span>
                </li>
                <li>
                    <a href="">__slots__</a>
                    <span>
                        限制该类实例能添加的属性<br>
                        __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称 <br>
                        对继承的子类是不起作用，除非在子类中也定义__slots__，这样，子类实例允许定义的属性就是自身的__slots__加上父类的__slots__
                    </span>
                </li>
                <li>
                    <a href="">__len__</a>(self)
                    <span>
                        自定义len函数返回，则设置__len__()方法
                    </span>
                </li>
                <li>
                    <a href="">__str__</a>(self)
                    <span>
                        打印实例时显示为字符串 <br>
                        __repr__() 变量时返回的字符串，用于调试 <br>
                        可设置 __repr__ = __str__
                    </span>
                </li>
                <li>
                    <a href="">__iter__</a>(self)
                    <span>
                        实例本身就是迭代对象，故返回自己 <br>
                        return self
                    </span>
                </li>
                <li>
                    <a href="">__next__</a>(self)
                    <span>
                        如果一个类想被用于for ... in循环，类似list或tuple那样，就必须实现一个__iter__()方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的__next__()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。
                    </span>
                </li>
                <li>
                    <a href="">__getitem__</a>(self,n)
                    <span>
                        要表现得像list那样按照下标取出元素，需要实现__getitem__()方法 <br>
                        <a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017590712115904">参考资料</a>
                    </span>
                </li>
                <li>
                    <a href="">__getattr__</a>(self,attr)
                    <span>
                        没有找到属性的情况下调用该方法
                    </span>
                </li>
                <li>
                    <a href="">__call__</a>(self)
                    <span>
                        对实例进行调用，obj()等同于调用__call__方法
                    </span>
                </li>
            </ul>
            <h4>[<span>-</span>] 装饰器</h4>
            <ul>
                <li>
                    <a href="">@property</a>
                    <span>
                        把一个方法变成属性获取 <br>
                        则obj.prop则调用内部的obj.prop() <br>
                        如不设置setter则说明为只读属性
                    </span>
                </li>
                <li>
                    <a href="">@prop.setter</a>
                    <span>
                        把一个方法变成属性修改 <br>
                        则obj.prop则调用内部的obj.prop() <br>
                        方法名和prop必须一致
                    </span>
                </li>
            </ul>
            <h4>[<span>-</span>] 继承</h4>
            <ul>
                <li>
                    <a href="">super</a>().__init__(arg)
                    <span>
                        返回一个代理对象，它会将方法调用委托给 type 指定的父类或兄弟类 <br>
                        1.子类继承父类，如果不重写__init__，实例子类时，默认调用父类__init__ <br>
                        2.如果子类重写了__init__ 时，实例化子类时默认不会调用父类已经定义的 __init__ <br>
                        3.要继承父类的构造方法，则需要在子类__init__中调用super方法 <br>
                        super(子类,obj) 调用创建obj实例的子类的父类
                    </span>
                </li>
                <li>
                    <a href="">issubclass</a>(child,parent)
                    <span>
                        1.如果 class 是 classinfo 的子类（直接、间接或 虚拟 的），则返回 true。<br>
                        2.classinfo 可以是类对象的元组，此时 classinfo 中的每个元素都会被检查。满足其中一个则返回true。
                    </span>
                </li>
            </ul>
            <h4>[<span>-</span>] 对象</h4>
            <ul>
                <li>
                    <a href="">dir</a>(obj)
                    <span>
                        获得一个对象的所有属性和方法 <br>
                        返回一个包含字符串的list
                    </span>
                </li>
                <li>
                    <a href="">hasattr</a>(obj,prop)
                    <span>
                        是否存在某个属性/方法 <br>
                        返回：True/False
                    </span>
                </li>
                <li>
                    <a href="">getattr</a>(obj,prop,[default])
                    <span>
                        获取某个属性/方法 <br>
                        返回：属性值 <br>
                        如果属性不存在会报错，可以设置default参数，如不存在则返回默认值
                    </span>
                </li>
                <li>
                    <a href="">setattr</a>(obj,prop,val)
                    <span>
                        设置某个属性/方法 <br>
                        返回：None
                    </span>
                </li>
                <li>
                    <a href="">delattr</a>(obj,prop)
                    <span>
                        删除某个属性/方法 <br>
                        返回：None
                    </span>
                </li>
                <li>
                    <a href="">MethodType</a>(fn,obj)
                    <span>
                        给类动态绑定一个新的方法，直接以属性赋值操作即可，但定义新增方法时，必须显示传入self作为第一个参数。 <br>
                        给实例绑定一个新的方法时，如果不涉及使用实例本身其他数据，则可以使用赋值引用方法，否则： <br>
                        from types import MethodType <br>
                        obj.fn = MethodType(fn,obj) <br>
                        def fn(self,arg):..
                    </span>
                </li>
                <li>
                    <a href="">super</a>(Parentcls,obj).fn
                    <span>
                        子类对象调用父类已被覆盖的方法
                    </span>
                </li>
            </ul>
        </div>
    </div>
    <div class="u-block">
        <h3>数据类型<span>-</span></h3>
        <div class="u-list">
            <h4>[<span>+</span>] 数据类型</h4>
            <ul style="display:none">
                <li>
                    <a href="">bool</a>
                    <span>
                        True / False <br>
                        区分大小写 <br>
                        在 Python2 中是没有布尔型的，它用数字 0 表示 False，用 1 表示 True。到 Python3 中，把 True 和 False 定义成关键字了，但它们的值还是 1 和 0，它们可以和数字相加。
                    </span>
                </li>
                <li>
                    <a href="">int</a>
                    <span>
                        整数，支持多进制
                    </span>
                </li>
                <li>
                    <a href="">float</a>
                    <span>
                        1.23e9，1.23e-5
                    </span>
                </li>
                <li>
                    <a href="">complex</a>
                    <span>
                        3+4j
                    </span>
                </li>
                <li>
                    <a href="">str</a>
                    <span>
                        字符串不能被改变。
                    </span>
                </li>
                <li>
                    <a href="">list</a>
                    <span>
                        多元素列表：[1,'a'] <br>
                        空列表：[]
                    </span>
                </li>
                <li>
                    <a href="">tuple</a>
                    <span>
                        多元素元组：(1,'a') <br>
                        单元素元组：(1,) <br>
                        空元组：() <hr>
                        元组（tuple）与列表类似，不同之处：<br>
                        1.元组的元素不能修改和删除，但可以使用del语句来删除整个元组 <br>
                        2.tuple的元素不可改变，但它可以包含可变的对象，比如list列表。 <br>
                        3.当元组只有一个元素，需要在元素后添加逗号 tup2 = (20,) 否则非元组，而是单元素
                    </span>
                </li>
                <li>
                    <a href="">dict</a>
                    <span>
                        多元素字典：{'k':'v'} <br>
                        空字典：{} / dict()<hr>
                        1.在同一个字典中，键(key)必须是唯一的。<br>
                        2.字符串、整型、浮点型和元组都可以作为dict的key。
                    </span>
                </li>
                <li>
                    <a href="">set</a>
                    <span>
                        多元素集合：{'a','b'} <br>
                        空集合：set()<hr>
                        集合是一个无序不重复元素的序列。 <hr>
                        1.创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。<br>
                        2.使用set()时最多传入1个参数。
                    </span>
                </li>
                <li>
                    <a href="">Iterable</a>
                    <span>
                        from collections import Iterable <br>
                        isinstance(val,Iterable) 是否为可迭代类型
                    </span>
                </li>
                <li>
                    <a href="">Iterator</a>
                    <span>
                        from collections import Iterator <br>
                        isinstance((x for x in range(10)), Iterator) <br>
                        可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator <br>
                        生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator
                    </span>
                </li>
                <li>
                    <a href="">None</a>
                    <span>
                        空值
                    </span>
                </li>
            </ul>
            <h4>[<span>-</span>] 类型检测</h4>
            <ul>
                <li>
                    <a href="">isinstance</a>(var,type..)
                    <span>
                        判断变量所指的对象类型（包含继承） <br>
                        isinstance(a, int) <br>
                        isinstance(a, (list, tuple)) <br>
                    </span>
                </li>
                <li>
                    <a href="">type</a>(var)
                    <span>
                        查询变量所指的对象类型 <br>
                        检测一个类或内置类时，返回的是'type'，检测一个实例时，
                    </span>
                </li>
                <li>
                    <a href="">types.</a>fn
                    <span>
                        判断是否为函数 <br>
                        import types <br>
                        type(fn) == types.FunctionType | BuiltinFunctionType | types.LambdaType | GeneratorType
                    </span>
                </li>
            </ul>
            <h4>[<span>-</span>] 类型转换</h4>
            <ul>
                <li>
                    <a href="">str</a>(val)
                    <span>将对象转换为字符串</span>
                </li>
                <li>
                    <a href="">bool</a>(val)
                    <span>转换到布尔值</span>
                </li>
                <li>
                    <a href="">list</a>(ite)
                    <span>
                        将序列/字典的key/可迭代对象转换为一个列表
                    </span>
                </li>
                <li>
                    <a href="">tuple</a>(ite)
                    <span>将序列/字典的key/可迭代对象转换为一个元组</span>
                </li>
                <li>
                    <a href="">dict</a>(seq)
                    <span>
                        创建一个字典。<a href="http://www.runoob.com/python/python-func-dict.html">参考资料</a>
                        dict(key='val',..) <br>
                        dict([(key1,val2),(key2,val2)...]) 元组数组<br>
                        dict(([key1,val2],[key2,val2]...)) 数组元组<br>
                    </span>
                </li>
                <li>
                    <a href="">set</a>(ite)
                    <span>
                        将序列/字典的key/可迭代对象转换为一个可变集合
                    </span>
                </li>
                <li>
                    <a href="">frozenset</a>(ite)
                    <span>转换为不可变集合</span>
                </li>
                <li>
                    <a href="">enumerate</a>(ite,[start])
                    <span>
                        将一个可迭代对象输出一个枚举对象，默认start=0 <br> 
                        例如list这样就可以在for循环中同时迭代索引和元素本身 <br>
                        for i, value in enumerate(['A', 'B', 'C'])
                    </span>
                </li>
                <li>
                    <a href="">iter</a>(ite)
                    <span>
                        把list、dict、str等Iterable变成Iterator
                    </span>
                </li>
                <li>
                    <a href="">reversed</a>(seq)
                    <span>
                        返回一个反向的 iterator。 seq 必须是一个具有 __reversed__() 方法的对象或者是支持该序列协议（具有从``0`` 开始的整数类型参数的 __len__() 方法和 __getitem__() 方法）。
                    </span>
                </li>
                <li>
                    <a href="">object()</a>
                    <span>
                        返回一个没有特征的新对象。object 是所有类的基类。它具有所有 Python 类实例的通用方法。这个函数不接受任何实参。
                    </span>
                </li>
                <li>
                    <a href="">Enum</a>(name,(..))
                    <span>
                        from enum import Enum,unique <br>
                        @unique <br>
                        class Weekday(Enum): <br>
                            Sun = 0 <hr>
                        Weekday.Sun.name|value 获取枚举类指定的名称和值 <br>
                        Weekday(1)  <br>
                        既可以用成员名称引用枚举常量，又可以直接根据value的值获得枚举常量。
                    </span>
                </li>
            </ul>
        </div>
    </div>
    <div class="u-block">
        <h3>可迭代类型<span>-</span></h3>
        <div class="u-list">
            <h4>[<span>-</span>] 序列与集合操作</h4>
            <ul>
                <li>
                    <a href="">len</a>(val)
                    <span>
                        返回对象（字符、列表、元组、字典、集合等）长度或项目个数
                    </span>
                </li>
                <li>
                    val <a href="">in</a> box
                    <span>
                        如果对象（字符、列表、元组、字典、集合等）中包含给定的值/key返回 True
                    </span>
                </li>
                <li>
                    val <a href="">not in</a> box
                    <span>
                        如果对象（字符、列表、元组、字典、集合等）中不包含给定的值/key返回 True
                    </span>
                </li>
            </ul>
            <h4>[<span>-</span>] 序列操作</h4>
            <ul>
                <li>
                    seq <a href="">+</a> seq
                    <span>
                        对序列（字符串/列表/元组）进行组合
                    </span>
                </li>
                <li>
                    seq <a href="">*</a> n
                    <span>
                        重复序列（字符串/列表/元组）若干次
                    </span>
                </li>
                <li>
                    seq<a href="">[n]</a>
                    <span>
                        序列（字符串/列表/元组）指定索引值的值。 <br>
                        以 0 为开始值，-1 为从末尾的开始位置。 <br>
                        下标从0开始，第x个数的索引为x-1，索引为n时该元素为第n+1个
                    </span>
                </li>
                <li>
                    seq<a href="">[n:m:[step]]</a>
                    <span>
                        截取序列（字符串/列表/元组）指定索引范围内的值。 <br> 
                        seq[头下标:<尾下标>]，不包含最后位置 <br>
                        seq[n:m]为从第n+1个数到第m+1个数，但不包括m+1位置上的数，总共有m-n个数 <br>
                        seq[n::2]从n开始，每步进2（包含此指针位置上的数）进行提取 <br>
                        <a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431756919644a792ee4ead724ef7afab3f7f771b04f5000">参考资料</a>
                    </span>
                </li>
            </ul>
            <h4>[<span>-</span>] 可迭代类型</h4>
            <ul>
                <li>
                    <a href="">for val in</a> ite
                    <span>
                        遍历可迭代对象的一个或多个值
                    </span>
                </li>
                <li>
                    <a href="">zip</a>(*ite)
                    <span>
                        聚合多个迭代器对象中的元素 <br>
                        返回：Iterator <br>
                        相同索引位置的元素构成一个元组
                    </span>
                </li>
                <li>
                    <a href="">map</a>(fn,ite)
                    <span>
                        遍历ite执行fn <br>
                        返回：Iterator
                    </span>
                </li>
                <li>
                    <a href="">filter</a>(fn,ite)
                    <span>
                        过滤ite中执行fn返回True的元素 <br>
                        返回：Iterator
                    </span>
                </li>
                <li>
                    <a href="">reduce</a>(fn,ite)
                    <span>
                        递归ite执行fn,fn应具备2个参数 <br>
                        返回：函数中的return值 <br>
                        注意引入：from functools import reduce <br>
                    </span>
                </li>
                <li>
                    <a href="">sorted</a>(ite,key=fn,[reverse=False])
                    <span>
                        对iterable中的项进行排序 <br>
                        返回：一个新的列表 <br>
                        key指定排序前执行的函数，reverse是否反向
                    </span>
                </li>
            </ul>
        </div>
    </div>
    <div class="u-block">
        <h3>全局函数<span>-</span></h3>
        <div class="u-list">
            <h4>[<span>-</span>] 全局函数</h4>
            <ul>
                <li>
                    <a href="">eval</a>(str)
                    <span>
                        执行一个字符串表达式，并返回表达式的值<br>
                        expression -- 表达式。 <br>
                        globals -- 变量作用域，全局命名空间，如果被提供，则必须是一个字典对象。<br>
                        locals -- 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。<br>
                        <a href="http://www.runoob.com/python/python-func-eval.html">更多资料</a>
                    </span>
                </li>
                <li>
                    <a href="">repr</a>(val)
                    <span>将对象转化为供解释器读取的形式，返回一个对象的 string 格式</span>
                </li>
            </ul>
        </div>
    </div>
</div>